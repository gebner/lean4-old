<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lean Manual</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="whatIsLean.html"><strong aria-hidden="true">1.</strong> What is Lean</a></li><li class="chapter-item expanded "><a href="tour.html"><strong aria-hidden="true">2.</strong> Tour of Lean</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> Setting Up Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">3.1.</strong> Quickstart</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Language Manual</li><li class="chapter-item expanded "><a href="deptypes.html"><strong aria-hidden="true">4.</strong> Dependent Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simptypes.html"><strong aria-hidden="true">4.1.</strong> Simple Type Theory</a></li><li class="chapter-item expanded "><a href="typeobjs.html"><strong aria-hidden="true">4.2.</strong> Types as objects</a></li><li class="chapter-item expanded "><a href="funabst.html"><strong aria-hidden="true">4.3.</strong> Function Abstraction and Evaluation</a></li><li class="chapter-item expanded "><a href="introdef.html"><strong aria-hidden="true">4.4.</strong> Introducing Definitions</a></li><li class="chapter-item expanded "><a href="dep.html"><strong aria-hidden="true">4.5.</strong> What makes dependent type theory dependent?</a></li></ol></li><li class="chapter-item expanded "><a href="organization.html"><strong aria-hidden="true">5.</strong> Organizational features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sections.html"><strong aria-hidden="true">5.1.</strong> Sections</a></li><li class="chapter-item expanded "><a href="namespaces.html"><strong aria-hidden="true">5.2.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="implicit.html"><strong aria-hidden="true">5.3.</strong> Implicit Arguments</a></li><li class="chapter-item expanded "><a href="autobound.html"><strong aria-hidden="true">5.4.</strong> Auto Bound Implicit Arguments</a></li></ol></li><li class="chapter-item expanded "><a href="decltypes.html"><strong aria-hidden="true">6.</strong> Declaring New Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="enum.html"><strong aria-hidden="true">6.1.</strong> Enumerated Types</a></li><li class="chapter-item expanded "><a href="inductive.html"><strong aria-hidden="true">6.2.</strong> Inductive Types</a></li><li class="chapter-item expanded "><a href="struct.html"><strong aria-hidden="true">6.3.</strong> Structures</a></li><li class="chapter-item expanded "><a href="typeclass.html"><strong aria-hidden="true">6.4.</strong> Type classes</a></li><li class="chapter-item expanded "><a href="unifhint.html"><strong aria-hidden="true">6.5.</strong> Unification Hints</a></li></ol></li><li class="chapter-item expanded "><a href="builtintypes.html"><strong aria-hidden="true">7.</strong> Builtin Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="nat.html"><strong aria-hidden="true">7.1.</strong> Natural number</a></li><li class="chapter-item expanded "><a href="int.html"><strong aria-hidden="true">7.2.</strong> Integer</a></li><li class="chapter-item expanded "><a href="uint.html"><strong aria-hidden="true">7.3.</strong> Fixed precision unsigned integer</a></li><li class="chapter-item expanded "><a href="float.html"><strong aria-hidden="true">7.4.</strong> Float</a></li><li class="chapter-item expanded "><a href="array.html"><strong aria-hidden="true">7.5.</strong> Array</a></li><li class="chapter-item expanded "><a href="list.html"><strong aria-hidden="true">7.6.</strong> List</a></li><li class="chapter-item expanded "><a href="char.html"><strong aria-hidden="true">7.7.</strong> Character</a></li><li class="chapter-item expanded "><a href="string.html"><strong aria-hidden="true">7.8.</strong> String</a></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">7.9.</strong> Option</a></li><li class="chapter-item expanded "><a href="thunk.html"><strong aria-hidden="true">7.10.</strong> Thunk</a></li><li class="chapter-item expanded "><a href="task.html"><strong aria-hidden="true">7.11.</strong> Task and Thread</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">8.</strong> Functions</a></li><li class="chapter-item expanded "><a href="tactics.html"><strong aria-hidden="true">9.</strong> Tactics</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">10.</strong> Syntax Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="do.html"><strong aria-hidden="true">10.1.</strong> The do Notation</a></li><li class="chapter-item expanded "><a href="stringinterp.html"><strong aria-hidden="true">10.2.</strong> String Interpolation</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Other</li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">11.</strong> Frequently Asked Questions</a></li><li class="chapter-item expanded "><a href="lean3changes.html"><strong aria-hidden="true">12.</strong> Significant Changes from Lean 3</a></li><li class="chapter-item expanded "><a href="syntax_highlight_in_latex.html"><strong aria-hidden="true">13.</strong> Syntax Highlighting Lean in LaTeX</a></li><li class="chapter-item expanded affix "><li class="part-title">Development</li><li class="chapter-item expanded "><a href="commit_convention.html"><strong aria-hidden="true">14.</strong> Commit Convention</a></li><li class="chapter-item expanded "><a href="make/index.html"><strong aria-hidden="true">15.</strong> Building Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="make/ubuntu-16.04.html"><strong aria-hidden="true">15.1.</strong> Ubuntu Setup</a></li><li class="chapter-item expanded "><a href="make/osx-10.9.html"><strong aria-hidden="true">15.2.</strong> macOS Setup</a></li><li class="chapter-item expanded "><a href="make/msys2.html"><strong aria-hidden="true">15.3.</strong> Windows Setup</a></li><li class="chapter-item expanded "><a href="make/nix.html"><strong aria-hidden="true">15.4.</strong> Nix Setup (Experimental)</a></li></ol></li><li class="chapter-item expanded "><a href="mdbook.html"><strong aria-hidden="true">16.</strong> Building This Manual</a></li><li class="chapter-item expanded "><a href="fixing_tests.html"><strong aria-hidden="true">17.</strong> Fixing Tests</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">18.</strong> Debugging</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Lean Manual</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-lean" id="what-is-lean">What is Lean</a></h1>
<p>Lean is a functional programming language that makes it easy to
write correct and maintainable code.
You can also use Lean as an interactive theorem prover.</p>
<p>Lean programming primarily involves defining types and functions.
This allows your focus to remain on the problem domain and manipulating its data,
rather than the details of programming.</p>
<pre><code class="language-lean">-- Defines a function that takes a name and produces a greeting.
def getGreeting (name : String) := s!&quot;Hello, {name}! Isn't Lean great?&quot;

-- The `main` function is the entry point of your program.
-- Its type is `IO Unit` because it can perform `IO` operations (side effects).
def main : IO Unit :=
  -- Define a list of names
  let names := [&quot;Sebastian&quot;, &quot;Leo&quot;, &quot;Daniel&quot;]

  -- Map each name to a greeting
  let greetings := names.map getGreeting

  -- Print the list of greetings
  for greeting in greetings do
    IO.println greeting
</code></pre>
<p>Lean has numerous features, including:</p>
<ul>
<li>Type inference</li>
<li>First-class functions</li>
<li>Powerful data types</li>
<li>Pattern matching</li>
<li>Type classes</li>
<li>Extensible syntax</li>
<li>Hygienic macros</li>
<li>Dependent types</li>
<li>Metaprogramming framework</li>
<li>Multithreading</li>
<li>Verification: you can prove properties of your functions using Lean itself</li>
</ul>
<h1><a class="header" href="#tour-of-lean" id="tour-of-lean">Tour of Lean</a></h1>
<p>The best way to learn about Lean is to read and write Lean code.
This article will act as a tour through some of the key features of the Lean
language and give you some code snippets that you can execute on your machine.
To learn about setting up a development environment, check out <a href="./setup.html">Setting Up Lean</a>.</p>
<p>There are two primary concepts in Lean: functions and types.
This tour will emphasize features of the language which fall into
these two concepts.</p>
<h1><a class="header" href="#functions-and-namespaces" id="functions-and-namespaces">Functions and Namespaces</a></h1>
<p>The most fundamental pieces of any Lean program are functions organized into namespaces.
<a href="./functions.html">Functions</a> perform work on inputs to produce outputs,
and they are organized under <a href="./namespaces.html">namespaces</a>,
which are the primary way you group things in Lean.
They are defined using the <a href="./definitions.html"><code>def</code></a> command,
which give the function a name and define its arguments.</p>
<pre><code class="language-lean">namespace BasicFunctions

-- The `#eval` command evaluates an expression on the fly and prints the result.
#eval 2+2

-- You use 'def' to define a function. This one accepts a natural number
-- and returns a natural number.
-- Parentheses are optional for function arguments, except for when
-- you use an explicit type annotation.
-- Lean can often infer the type of the function's arguments.
def sampleFunction1 x := x*x + 3

-- Apply the function, naming the function return result using 'def'.
-- The variable type is inferred from the function return type.
def result1 := sampleFunction1 4573

-- This line uses an interpolated string to print the result. Expressions inside
-- braces `{}` are converted into strings using the polymorphic method `toString`
#eval println! &quot;The result of squaring the integer 4573 and adding 3 is {result1}&quot;

-- When needed, annotate the type of a parameter name using '(argument : type)'.
def sampleFunction2 (x : Nat) := 2*x*x - x + 3

def result2 := sampleFunction2 (7 + 4)

#eval println! &quot;The result of applying the 2nd sample function to (7 + 4) is {result2}&quot;

-- Conditionals use if/then/else
def sampleFunction3 (x : Int) :=
  if x &gt; 100 then
    2*x*x - x + 3
  else
    2*x*x + x - 37

#eval println! &quot;The result of applying sampleFunction3 to 2 is {sampleFunction3 2}&quot;

end BasicFunctions
</code></pre>
<pre><code class="language-lean">-- Lean has first-class functions.
-- `twice` takes two arguments `f` and `a` where
-- `f` is a function from natural numbers to natural numbers, and
-- `a` is a natural number.
def twice (f : Nat → Nat) (a : Nat) :=
  f (f a)

-- `fun` is used to declare anonymous functions
#eval twice (fun x =&gt; x + 2) 10

-- You can prove theorems about your functions.
-- The following theorem states that for any natural number `a`,
-- adding 2 twice produces a value equal to `a + 4`.
theorem twiceAdd2 (a : Nat) : twice (fun x =&gt; x + 2) a = a + 4 :=
  -- The proof is by reflexivity. Lean &quot;symbolically&quot; reduces both sides of the equality
  -- until they are identical.
  rfl

-- `(. + 2)` is syntax sugar for `(fun x =&gt; x + 2)`. The parentheses + `.` notation
-- is useful for defining simple anonymous functions.
#eval twice (. + 2) 10

-- Enumerated types are a special case of inductive types in Lean,
-- which we will learn about later.
-- The following command creates a new type `Weekday`.
inductive Weekday where
  | sunday    : Weekday
  | monday    : Weekday
  | tuesday   : Weekday
  | wednesday : Weekday
  | thursday  : Weekday
  | friday    : Weekday
  | saturday  : Weekday

-- `Weekday` has 7 constructors/elements.
-- The constructors live in the `Weekday` namespace.
-- Think of `sunday`, `monday`, …, `saturday` as being distinct elements of `Weekday`,
-- with no other distinguishing properties.
-- The command `#check` prints the type of a term in Lean.
#check Weekday.sunday
#check Weekday.monday

-- The `open` command opens a namespace, making all declarations in it accessible without
-- qualification.
open Weekday
#check sunday
#check tuesday

-- You can define functions by pattern matching.
-- The following function converts a `Weekday` into a natural number.
def natOfWeekday (d : Weekday) : Nat :=
  match d with
  | sunday    =&gt; 1
  | monday    =&gt; 2
  | tuesday   =&gt; 3
  | wednesday =&gt; 4
  | thursday  =&gt; 5
  | friday    =&gt; 6
  | saturday  =&gt; 7

#eval natOfWeekday tuesday

def isMonday : Weekday → Bool :=
  -- `fun` + `match`  is a common idiom.
  -- The following expression is syntax sugar for
  -- `fun d =&gt; match d with | monday =&gt; true | _ =&gt; false`.
  fun
    | monday =&gt; true
    | _      =&gt; false

#eval isMonday monday
#eval isMonday sunday

-- Lean has support for type classes and polymorphic methods.
-- The `toString` method converts a value into a `String`.
#eval toString 10
#eval toString (10, 20)

-- The method `toString` converts values of any type that implements
-- the class `ToString`.
-- You can implement instances of `ToString` for your own types.
instance : ToString Weekday where
  toString (d : Weekday) : String :=
    match d with
    | sunday    =&gt; &quot;Sunday&quot;
    | monday    =&gt; &quot;Monday&quot;
    | tuesday   =&gt; &quot;Tuesday&quot;
    | wednesday =&gt; &quot;Wednesday&quot;
    | thursday  =&gt; &quot;Thursday&quot;
    | friday    =&gt; &quot;Friday&quot;
    | saturday  =&gt; &quot;Saturday&quot;

#eval toString (sunday, 10)

def Weekday.next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

#eval Weekday.next Weekday.wednesday
-- Since the `Weekday` namespace has already been opened, you can also write
#eval next wednesday

-- Matching on a parameter like in the previous definition
-- is so common that Lean provides syntax sugar for it. The following
-- function uses it.
def Weekday.previous : Weekday -&gt; Weekday
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday

#eval next (previous wednesday)

-- We can prove that for any `Weekday` `d`, `next (previous d) = d`
theorem Weekday.nextOfPrevious (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl

-- You can automate definitions such as `Weekday.nextOfPrevious`
-- using metaprogramming (or &quot;tactics&quot;).
theorem Weekday.nextOfPrevious' (d : Weekday) : next (previous d) = d := by
  cases d       -- A proof by case distinction
  allGoals rfl  -- Each case is solved using `rfl`
</code></pre>
<h1><a class="header" href="#setting-up-lean" id="setting-up-lean">Setting Up Lean</a></h1>
<p>There are currently two ways to set up a Lean 4 development environment:</p>
<ul>
<li><a href="./setup.html#basic-setup">basic setup</a> (Linux/macOS/Windows): uses <a href="https://github.com/leanprover/elan"><code>elan</code></a> + your preinstalled editor</li>
<li><a href="./setup.html#nix-setup">Nix setup</a> (Linux/macOS/WSL): uses the <a href="https://nixos.org/nix/">Nix</a> package manager for installing all dependencies localized to your project</li>
</ul>
<p>See also the <a href="./quickstart.html">quickstart</a> instructions for using the basic setup with VS Code as the editor.</p>
<h2><a class="header" href="#basic-setup" id="basic-setup">Basic Setup</a></h2>
<p>Release builds for all supported platforms are available at <a href="https://github.com/leanprover/lean4/releases">https://github.com/leanprover/lean4/releases</a>.
Instead of downloading these and setting up the paths manually, however, it is recommended to use the Lean version manager <a href="https://github.com/leanprover/elan"><code>elan</code></a> instead:</p>
<pre><code class="language-sh">$ elan self update  # in case you haven't updated elan in a while
# download &amp; activate latest Lean 4 release (https://github.com/leanprover/lean4/releases)
$ elan default leanprover/lean4:stable
# alternatively, use the latest nightly build (https://github.com/leanprover/lean4-nightly/releases)
$ elan default leanprover/lean4:nightly
# alternatively, activate Lean 4 in current directory only
$ elan override set leanprover/lean4:stable
</code></pre>
<h3><a class="header" href="#leanpkg" id="leanpkg"><code>leanpkg</code></a></h3>
<p>Lean 4 comes with a basic package manager, <code>leanpkg</code>.
Use <code>leanpkg init Foo</code> to initialize a Lean package <code>Foo</code> in the current directory, and <code>leanpkg build</code> to typecheck and build it as well as all its dependencies; call <code>leanpkg help</code> to learn about further commands.
The general directory structure of a package <code>Foo</code> is</p>
<pre><code class="language-sh">leanpkg.toml  # package configuration
Foo.lean  # main file, import via `import Foo`
Foo/
  A.lean  # further files, import via e.g. `import Foo.A`
  A/...   # further nesting
build/  # `leanpkg` output directory
</code></pre>
<p>Note however that <code>leanpkg</code> currently depends on <code>make</code> (and <code>sh</code>) for recursive compilation.
It has been tested on Windows by installing these tools using <a href="https://www.msys2.org/">MSYS2</a>, but <a href="http://www.mingw.org/">MinGW</a> or WSL should work, too.</p>
<h3><a class="header" href="#editing" id="editing">Editing</a></h3>
<p>Lean implements the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> that can be used for interactive development in <a href="https://github.com/leanprover/lean4/tree/master/lean4-mode/README.md">Emacs</a>, <a href="https://github.com/mhuisi/vscode-lean4">VS Code</a>, and possibly other editors.</p>
<p>Changes must be saved to be visible in other files, which must then be invalidated using an editor command (see links above).</p>
<h2><a class="header" href="#nix-setup" id="nix-setup">Nix Setup</a></h2>
<p>The alternative setup based on Nix provides a perfectly reproducible development environment for your project from the Lean version down to the editor and Lean extension.
However, it is still experimental and subject to change; in particular, it is heavily based on an unreleased version of Nix enabling <a href="https://www.tweag.io/blog/2020-05-25-flakes/">Nix Flakes</a>. The setup has been tested on NixOS, other Linux distributions, and macOS.</p>
<p>After installing (any version of) Nix (<a href="https://nixos.org/download.html">https://nixos.org/download.html</a>), you can easily open a shell with the particular pre-release version of Nix needed by and tested with our setup (called the &quot;Lean shell&quot; from here on):</p>
<pre><code class="language-bash">$ nix-shell https://github.com/leanprover/lean4/archive/master.tar.gz -A nix
</code></pre>
<p>While this shell is sufficient for executing the steps below, it is recommended to also set the following options in <code>/etc/nix/nix.conf</code> (<code>nix.extraOptions</code> in NixOS):</p>
<pre><code>max-jobs = auto  # Allow building multiple derivations in parallel
keep-outputs = true  # Do not garbage-collect build time-only dependencies (e.g. clang)
# Allow fetching build results from the Lean Cachix cache
trusted-substituters = https://lean4.cachix.org/
trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= lean4.cachix.org-1:mawtxSxcaiWE24xCXXgh3qnvlTkyU7evRRnGeAhD4Wk=
</code></pre>
<p>On a multi-user installation of Nix (the default), you need to restart the Nix daemon afterwards:</p>
<pre><code class="language-bash">sudo pkill nix-daemon
</code></pre>
<p>The <a href="https://cachix.org/">Cachix</a> integration will magically beam any build steps already executed by the CI right onto your machine when calling Nix commands in the shell opened above.
It can be set up analogously as a cache for your own project.</p>
<p>Note: Your system Nix might print warnings about not knowing some of the settings used by the Lean shell Nix, which can be ignored.</p>
<h3><a class="header" href="#basic-commands" id="basic-commands">Basic Commands</a></h3>
<p>From a Lean shell, run</p>
<pre><code class="language-bash">$ nix flake new mypkg -t github:leanprover/lean4
$ cd mypkg &amp;&amp; git init &amp;&amp; git add flake.nix
</code></pre>
<p>to create a new Lean package in directory <code>mypkg</code> using the latest commit of Lean 4.
Note that Nix Flakes will not recognize your <code>flake.nix</code> file unless it is visible to Git.
Such packages follow the same directory layout as described in the basic setup above, except for a <code>leanpkg.toml</code> replaced by a <code>flake.nix</code> file set up so you can run Nix commands on it, for example:</p>
<pre><code class="language-bash">$ nix build  # build package and all dependencies
$ nix build .#executable  # compile `main` definition into executable (after you've added one)
$ nix run .#emacs-dev  # open a pinned version of Emacs with lean4-mode fully set up
$ nix run .#emacs-dev MyPackage.lean  # arguments can be passed as well, e.g. the file to open
$ nix run .#vscode-dev MyPackage.lean  # ditto, using VS Code
</code></pre>
<p>Note that if you rename <code>MyPackage.lean</code>, you also have to adjust the <code>name</code> attribute in <code>flake.nix</code> accordingly.</p>
<p>As in the basic setup, changes need to be saved to be visible in other files, which have then to be invalidated via an editor command.</p>
<p>If you don't want to or cannot start the pinned editor from Nix, e.g. because you're running Lean inside WSL/a container/on a different machine, you can manually point your editor at the <code>lean</code> wrapper script the commands above use internally:</p>
<pre><code class="language-bash">$ nix build .#lean-dev -o result-lean-dev
</code></pre>
<p>The resulting <code>./result-lean-dev/bin/lean</code> script essentially runs <code>nix run .#lean</code> in the current project's root directory when you open a Lean file or use the &quot;refresh dependencies&quot; command such that the correct Lean version for that project is executed.
This includes selecting the correct stage of Lean (which it will compile on the fly, though without progress output) if you are <a href="../make/nix.html#editor-integration">working on Lean itself</a>.</p>
<p>Package dependencies can be added as further input flakes and passed to the <code>deps</code> list of <code>buildLeanPackage</code>. Example: <a href="https://github.com/Kha/testpkg2/blob/master/flake.nix#L5">https://github.com/Kha/testpkg2/blob/master/flake.nix#L5</a></p>
<p>For hacking, it can be useful to temporarily override an input with a local checkout/different version of a dependency:</p>
<pre><code class="language-bash">$ nix build --override-input somedep path/to/somedep
</code></pre>
<p>On a build error, Nix will show the last 10 lines of the output by default. You can pass <code>-L</code> to <code>nix build</code> to show all lines, or pass the shown <code>*.drv</code> path to <code>nix log</code> to show the full log after the fact.</p>
<p>Keeping all outputs ever built on a machine alive can accumulate to quite impressive amounts of disk space, so you might want to trigger the Nix GC when <code>/nix/store/</code> has grown too large:</p>
<pre><code class="language-bash">nix-collect-garbage
</code></pre>
<p>This will remove everything not reachable from &quot;GC roots&quot; such as the <code>./result</code> symlink created by <code>nix build</code>.</p>
<p>Note that the package information in <code>flake.nix</code> is currently completely independent from <code>leanpkg.toml</code> used in the basic setup.
Unifying the two formats is TBD.</p>
<h1><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h1>
<p>These instructions will walk you through setting up Lean using the &quot;basic&quot; setup and VS Code as the editor.
See <a href="./setup.html">Setup</a> for other ways and more details on setting up Lean.</p>
<ol>
<li>Install the latest Lean 4 nightly through <a href="https://github.com/leanprover/elan"><code>elan</code></a>: in any bash-compatible shell, run
<pre><code class="language-sh">$ curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh -s -- --default-toolchain leanprover/lean4:nightly
</code></pre>
See the <code>elan</code> link above for other installation options and details.
Note that using Lean with multi-file projects on Windows currently comes with some <a href="./setup.html#leanpkg">additional limitations</a>.</li>
<li>Install <a href="https://code.visualstudio.com/">VS Code</a>.</li>
<li>Open VS Code and install the <code>lean4</code> extension.<br />
<img src="images/code-ext.png" alt="installing the vscode-lean4 extension" /></li>
<li>Create a new file with the extension <code>.lean</code> and add the following code:
<pre><code class="language-lean">import Leanpkg

#eval Leanpkg.leanVersionString
</code></pre>
You should get a syntax-highlighted file with a &quot;Lean Infoview&quot; on the right that tells you the installed Lean version when placing your cursor on the last line.<br />
<img src="images/code-success.png" alt="successful setup" /></li>
<li>You are set up! Try opening a Lean package with a <code>leanpkg.toml</code>. You can create your own packages using <code>leanpkg init</code> on the command line.
Packages <strong>have</strong> to be opened using &quot;File &gt; Open Folder...&quot; for imports to work.
Saved changes are visibly in other files after running &quot;Lean 4: Refresh File Dependencies&quot; (<code>Ctrl+Shift+X</code>) in them.</li>
</ol>
<h1><a class="header" href="#dependent-types" id="dependent-types">Dependent Types</a></h1>
<p>In this section, we introduce simple type theory, types as objects, definitions, and explain what makes dependent type theory <em>dependent</em>.</p>
<h2><a class="header" href="#simple-type-theory" id="simple-type-theory">Simple Type Theory</a></h2>
<p>&quot;Type theory&quot; gets its name from the fact that every expression has an associated <em>type</em>.
For example, in a given context, <code>x + 0</code> may denote a natural number and <code>f</code> may denote a function on the natural numbers.
For those that don't like math, a Lean natural number is an arbitrary-precision unsigned integer.</p>
<p>Here are some examples of how we can declare objects in Lean and check their types.</p>
<pre><code class="language-lean">/- Declare some constants. -/

constant m  : Nat   -- m is a natural number
constant n  : Nat
constant b1 : Bool  -- b1 is a Boolean
constant b2 : Bool

/- Check their types. -/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- &quot;&amp;&amp;&quot; is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean &quot;true&quot;
</code></pre>
<p>Any text between <code>/-</code> and <code>-/</code> constitutes a comment block that is ignored by Lean.
Similarly, two dashes <code>--</code> indicate that the rest of the line contains a comment that is also ignored.
Comment blocks can be nested, making it possible to &quot;comment out&quot; chunks of code, just as in many programming languages.</p>
<p>The <code>constant</code> command introduce new constant symbols into the working environment.
The <code>#check</code> command asks Lean to report their types; in Lean, auxiliary commands that query the system for
information typically begin with the hash symbol. You should try declaring some constants and type checking
some expressions on your own. Declaring new objects in this way is a good way to experiment with the system.</p>
<p>What makes simple type theory powerful is that one can build new types out of others.
For example, if <code>a</code> and <code>b</code> are types, <code>a -&gt; b</code> denotes the type of functions from <code>a</code> to <code>b</code>,
and <code>a × b</code> denotes the type of pairs consisting of an element of <code>a</code>
paired with an element of <code>b</code>, also known as the <em>Cartesian product</em>.
Note that <code>×</code> is a Unicode symbol. We believe that judicious use of Unicode improves legibility,
and all modern editors have great support for it. In the Lean standard library, we often use
Greek letters to denote types, and the Unicode symbol <code>→</code> as a more compact version of <code>-&gt;</code>.</p>
<pre><code class="language-lean">constant m : Nat
constant n : Nat

constant f  : Nat → Nat         -- type the arrow as &quot;\to&quot; or &quot;\r&quot;
constant f' : Nat -&gt; Nat        -- alternative ASCII notation
constant p  : Nat × Nat         -- type the product as &quot;\times&quot;
constant q  : Prod Nat Nat      -- alternative notation
constant g  : Nat → Nat → Nat
constant g' : Nat → (Nat → Nat) -- has the same type as g!
constant h  : Nat × Nat → Nat
constant F  : (Nat → Nat) → Nat -- a &quot;functional&quot;

#check f            -- Nat → Nat
#check f n          -- Nat
#check g m n        -- Nat
#check g m          -- Nat → Nat
#check (m, n)       -- Nat × Nat
#check p.1          -- Nat
#check p.2          -- Nat
#check (m, n).1     -- Nat
#check (p.1, n)     -- Nat × Nat
#check F f          -- Nat
</code></pre>
<p>Once again, you should try some examples on your own.</p>
<p>Let us dispense with some basic syntax. You can enter the unicode arrow <code>→</code> by typing <code>\to</code> or <code>\r</code>.
You can also use the ASCII alternative <code>-&gt;</code>, so the expressions <code>Nat -&gt; Nat</code> and <code>Nat → Nat</code> mean the same thing.
Both expressions denote the type of functions that take a natural number as input and return a natural number as output.
The unicode symbol <code>×</code> for the Cartesian product is entered as <code>\times</code>.
We will generally use lower-case Greek letters like <code>α</code>, <code>β</code>, and <code>γ</code> to range over types.
You can enter these particular ones with <code>\a</code>, <code>\b</code>, and <code>\g</code>.</p>
<p>There are a few more things to notice here. First, the application of a function <code>f</code> to a value <code>x</code> is denoted <code>f x</code>.
Second, when writing type expressions, arrows associate to the <em>right</em>; for example, the type of <code>g</code> is <code>Nat → (Nat → Nat)</code>.
Thus we can view <code>g</code> as a function that takes natural numbers and returns another function that takes a natural number and
returns a natural number.
In type theory, this is generally more convenient than writing <code>g</code> as a function that takes a pair of natural numbers as input
and returns a natural number as output. For example, it allows us to &quot;partially apply&quot; the function <code>g</code>.
The example above shows that <code>g m</code> has type <code>Nat → Nat</code>, that is, the function that &quot;waits&quot; for a second argument, <code>n</code>,
and then returns <code>g m n</code>. Taking a function <code>h</code> of type <code>Nat × Nat → Nat</code> and &quot;redefining&quot; it to look like <code>g</code> is a process
known as <em>currying</em>, something we will come back to below.</p>
<p>By now you may also have guessed that, in Lean, <code>(m, n)</code> denotes the ordered pair of <code>m</code> and <code>n</code>,
and if <code>p</code> is a pair, <code>p.1</code> and <code>p.2</code> denote the two projections.</p>
<h2><a class="header" href="#types-as-objects" id="types-as-objects">Types as objects</a></h2>
<p>One way in which Lean's dependent type theory extends simple type theory is that types themselves --- entities like <code>Nat</code> and <code>Bool</code> ---
are first-class citizens, which is to say that they themselves are objects. For that to be the case, each of them also has to have a type.</p>
<pre><code class="language-lean">#check Nat               -- Type
#check Bool              -- Type
#check Nat → Bool        -- Type
#check Nat × Bool        -- Type
#check Nat → Nat         -- ...
#check Nat × Nat → Nat
#check Nat → Nat → Nat
#check Nat → (Nat → Nat)
#check Nat → Nat → Bool
#check (Nat → Nat) → Nat
</code></pre>
<p>We see that each one of the expressions above is an object of type <code>Type</code>. We can also declare new constants and constructors for types:</p>
<pre><code class="language-lean">constant α : Type
constant β : Type
constant F : Type → Type
constant G : Type → Type → Type

#check α        -- Type
#check F α      -- Type
#check F Nat    -- Type
#check G α      -- Type → Type
#check G α β    -- Type
#check G α Nat  -- Type
</code></pre>
<p>Indeed, we have already seen an example of a function of type <code>Type → Type → Type</code>, namely, the Cartesian product.</p>
<pre><code class="language-lean">constant α : Type
constant β : Type

#check Prod α β       -- Type
#check Prod Nat Nat   -- Type
</code></pre>
<p>Here is another example: given any type <code>α</code>, the type <code>List α</code> denotes the type of lists of elements of type <code>α</code>.</p>
<pre><code class="language-lean">constant α : Type

#check List α    -- Type
#check List Nat  -- Type
</code></pre>
<p>Given that every expression in Lean has a type, it is natural to ask: what type does <code>Type</code> itself have?</p>
<pre><code class="language-lean">#check Type      -- Type 1
</code></pre>
<p>We have actually come up against one of the most subtle aspects of Lean's typing system.
Lean's underlying foundation has an infinite hierarchy of types:</p>
<pre><code class="language-lean">#check Type     -- Type 1
#check Type 1   -- Type 2
#check Type 2   -- Type 3
#check Type 3   -- Type 4
#check Type 4   -- Type 5
</code></pre>
<p>Think of <code>Type 0</code> as a universe of &quot;small&quot; or &quot;ordinary&quot; types.
<code>Type 1</code> is then a larger universe of types, which contains <code>Type 0</code> as an element,
and <code>Type 2</code> is an even larger universe of types, which contains <code>Type 1</code> as an element.
The list is indefinite, so that there is a <code>Type n</code> for every natural number <code>n</code>.
<code>Type</code> is an abbreviation for <code>Type 0</code>:</p>
<pre><code class="language-lean">#check Type
#check Type 0
</code></pre>
<p>There is also another type universe, <code>Prop</code>, which has special properties.</p>
<pre><code class="language-lean">#check Prop -- Type
</code></pre>
<p>We will discuss <code>Prop</code> later.</p>
<p>We want some operations, however, to be <em>polymorphic</em> over type universes. For example, <code>List α</code> should
make sense for any type <code>α</code>, no matter which type universe <code>α</code> lives in. This explains the type annotation of the function <code>List</code>:</p>
<pre><code class="language-lean">#check List    -- Type u_1 → Type u_1
</code></pre>
<p>Here <code>u_1</code> is a variable ranging over type levels. The output of the <code>#check</code> command means that whenever <code>α</code> has type <code>Type n</code>, <code>List α</code> also has type <code>Type n</code>. The function <code>Prod</code> is similarly polymorphic:</p>
<pre><code class="language-lean">#check Prod    -- Type u_1 → Type u_2 → Type (max u_1 u_2)
</code></pre>
<p>To define polymorphic constants and variables, Lean allows us to declare universe variables explicitly using the <code>universe</code> command:</p>
<pre><code class="language-lean">universe u
constant α : Type u
#check α
</code></pre>
<p>Equivalently, we can write <code>Type _</code> to avoid giving the arbitrary universe a name:</p>
<pre><code class="language-lean">constant α : Type _
#check α
</code></pre>
<p>Several Lean 3 users use the shorthand <code>Type*</code> for <code>Type _</code>. The <code>Type*</code> notation is not builtin in Lean 4, but you can easily define it using a <code>macro</code>.</p>
<pre><code class="language-lean">macro &quot;Type*&quot; : term =&gt; `(Type _)

def f (α : Type*) (a : α) := a

def g (α : Type _) (a : α) := a

#check f
#check g
</code></pre>
<p>We explain later how the <code>macro</code> command works.</p>
<h2><a class="header" href="#function-abstraction-and-evaluation" id="function-abstraction-and-evaluation">Function Abstraction and Evaluation</a></h2>
<p>We have seen that if we have <code>m n : Nat</code>, then we have <code>(m, n) : Nat × Nat</code>.
This gives us a way of creating pairs of natural numbers.
Conversely, if we have <code>p : Nat × Nat</code>, then
we have <code>p.1 : Nat</code> and <code>p.2 : Nat</code>.
This gives us a way of &quot;using&quot; a pair, by extracting its two components.</p>
<p>We already know how to &quot;use&quot; a function <code>f : α → β</code>, namely,
we can apply it to an element <code>a : α</code> to obtain <code>f a : β</code>.
But how do we create a function from another expression?</p>
<p>The companion to application is a process known as &quot;lambda abstraction.&quot;
Suppose that giving a variable <code>x : α</code> we can construct an expression <code>t : β</code>.
Then the expression <code>fun (x : α) =&gt; t</code>, or, equivalently, <code>λ (x : α) =&gt; t</code>, is an object of type <code>α → β</code>.
Think of this as the function from <code>α</code> to <code>β</code> which maps any value <code>x</code> to the value <code>t</code>,
which may depend on <code>x</code>.</p>
<pre><code class="language-lean">#check fun (x : Nat) =&gt; x + 5
#check λ (x : Nat) =&gt; x + 5
#check fun x : Nat =&gt; x + 5
#check λ x : Nat =&gt; x + 5
</code></pre>
<p>Here are some more examples:</p>
<pre><code class="language-lean">constant f : Nat → Nat
constant h : Nat → Bool → Nat

#check fun x : Nat =&gt; fun y : Bool =&gt; h (f x) y   -- Nat → Bool → Nat
#check fun (x : Nat) (y : Bool) =&gt; h (f x) y      -- Nat → Bool → Nat
#check fun x y =&gt; h (f x) y                       -- Nat → Bool → Nat
</code></pre>
<p>Lean interprets the final three examples as the same expression; in the last expression,
Lean infers the type of <code>x</code> and <code>y</code> from the types of <code>f</code> and <code>h</code>.</p>
<p>Some mathematically common examples of operations of functions can be described in terms of lambda abstraction:</p>
<pre><code class="language-lean">constant f : Nat → String
constant g : String → Bool
constant b : Bool

#check fun x : Nat =&gt; x        -- Nat → Nat
#check fun x : Nat =&gt; b        -- Nat → Bool
#check fun x : Nat =&gt; g (f x)  -- Nat → Bool
#check fun x =&gt; g (f x)        -- Nat → Bool
</code></pre>
<p>Think about what these expressions mean. The expression <code>fun x : Nat =&gt; x</code> denotes the identity function on <code>Nat</code>,
the expression <code>fun x : α =&gt; b</code> denotes the constant function that always returns <code>b</code>,
and <code>fun x : Nat =&gt; g (f x)</code>, denotes the composition of <code>f</code> and <code>g</code>.
We can, in general, leave off the type annotation on a variable and let Lean infer it for us.
So, for example, we can write <code>fun x =&gt; g (f x)</code> instead of <code>fun x : Nat =&gt; g (f x)</code>.</p>
<p>We can abstract over the constants <code>f</code> and <code>g</code> in the previous definitions:</p>
<pre><code class="language-lean">#check fun (g : String → Bool) (f : Nat → String) (x : Nat) =&gt; g (f x)
-- (String → Bool) → (Nat → String) → Nat → Bool
</code></pre>
<p>We can also abstract over types:</p>
<pre><code class="language-lean">#check fun (α β γ : Type) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)
</code></pre>
<p>The last expression, for example, denotes the function that takes three types, <code>α</code>, <code>β</code>, and <code>γ</code>, and two functions, <code>g : β → γ</code> and <code>f : α → β</code>, and returns the composition of <code>g</code> and <code>f</code>. (Making sense of the type of this function requires an understanding of dependent products, which we will explain below.) Within a lambda expression <code>fun x : α =&gt; t</code>, the variable <code>x</code> is a &quot;bound variable&quot;: it is really a placeholder, whose &quot;scope&quot; does not extend beyond <code>t</code>.
For example, the variable <code>b</code> in the expression <code>fun (b : β) (x : α) =&gt; b</code> has nothing to do with the constant <code>b</code> declared earlier.
In fact, the expression denotes the same function as <code>fun (u : β) (z : α), u</code>. Formally, the expressions that are the same up to a renaming of bound variables are called <em>alpha equivalent</em>, and are considered &quot;the same.&quot; Lean recognizes this equivalence.</p>
<p>Notice that applying a term <code>t : α → β</code> to a term <code>s : α</code> yields an expression <code>t s : β</code>.
Returning to the previous example and renaming bound variables for clarity, notice the types of the following expressions:</p>
<pre><code class="language-lean">#check (fun x : Nat =&gt; x) 1     -- Nat
#check (fun x : Nat =&gt; true) 1  -- Bool

constant f : Nat → String
constant g : String → Bool

#check
  (fun (α β γ : Type) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)) Nat String Bool g f 0
  -- Bool
</code></pre>
<p>As expected, the expression <code>(fun x : Nat =&gt;  x) 1</code> has type <code>Nat</code>.
In fact, more should be true: applying the expression <code>(fun x : Nat =&gt; x)</code> to <code>1</code> should &quot;return&quot; the value <code>1</code>. And, indeed, it does:</p>
<pre><code class="language-lean">#reduce (fun x : Nat =&gt; x) 1     -- 1
#reduce (fun x : Nat =&gt; true) 1  -- true

constant f : Nat → String
constant g : String → Bool

#reduce
  (fun (α β γ : Type) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)) Nat String Bool g f 0
  -- g (f 0)
</code></pre>
<p>The command <code>#reduce</code> tells Lean to evaluate an expression by <em>reducing</em> it to its normal form,
which is to say, carrying out all the computational reductions that are sanctioned by its kernel.
The process of simplifying an expression <code>(fun x =&gt; t) s</code> to <code>t[s/x]</code> -- that is, <code>t</code> with <code>s</code> substituted for the variable <code>x</code> --
is known as <em>beta reduction</em>, and two terms that beta reduce to a common term are called <em>beta equivalent</em>.
But the <code>#reduce</code> command carries out other forms of reduction as well:</p>
<pre><code class="language-lean">constant m : Nat
constant n : Nat
constant b : Bool

#reduce (m, n).1        -- m
#reduce (m, n).2        -- n

#reduce true &amp;&amp; false   -- false
#reduce false &amp;&amp; b      -- false
#reduce b &amp;&amp; false      -- Bool.rec false false b

#reduce n + 0           -- n
#reduce n + 2           -- Nat.succ (Nat.succ n)
#reduce 2 + 3           -- 5
</code></pre>
<p>We explain later how these terms are evaluated.
For now, we only wish to emphasize that this is an important feature of dependent type theory:
every term has a computational behavior, and supports a notion of reduction, or <em>normalization</em>.
In principle, two terms that reduce to the same value are called <em>definitionally equal</em>.
They are considered &quot;the same&quot; by Lean's type checker, and Lean does its best to recognize and support these identifications.
The <code>#reduce</code> command is mainly useful to understand why two terms are considered the same.</p>
<p>Lean is also a programming language. It has a compiler to native code and an interpreter.
You can use the command <code>#eval</code> to execute expressions, and it is the preferred way of testing your functions.
Note that <code>#eval</code> and <code>#reduce</code> are <em>not</em> equivalent. The command <code>#eval</code> first compiles Lean expressions
into an intermediate representation (IR) and then uses an interpreter to execute the generated IR.
Some builtin types (e.g., <code>Nat</code>, <code>String</code>, <code>Array</code>) have a more efficient representation in the IR.
The IR has support for using foreign functions that are opaque to Lean.</p>
<p>In contrast, the <code>#reduce</code> command relies on a reduction engine similar to the one used in Lean's trusted kernel,
the part of Lean that is responsible for checking and verifying the correctness of expressions and proofs.
It is less efficient than <code>#eval</code>, and treats all foreign functions as opaque constants.
We later discuss other differences between the two commands.</p>
<h2><a class="header" href="#introducing-definitions" id="introducing-definitions">Introducing Definitions</a></h2>
<p>The <code>def</code> command provides one important way of defining new objects.</p>
<pre><code class="language-lean">
def foo : (Nat → Nat) → Nat :=
  fun f =&gt; f 0

#check foo   -- (Nat → Nat) → Nat
#print foo
</code></pre>
<p>We can omit the type when Lean has enough information to infer it:</p>
<pre><code class="language-lean">def foo :=
  fun (f : Nat → Nat) =&gt; f 0
</code></pre>
<p>The general form of a definition is <code>def foo : α := bar</code>. Lean can usually infer the type <code>α</code>, but it is often a good idea to write it explicitly.
This clarifies your intention, and Lean will flag an error if the right-hand side of the definition does not have the right type.</p>
<p>Lean also allows us to use an alternative format that puts the abstracted variables before the colon and omits the lambda:</p>
<pre><code class="language-lean">def double (x : Nat) : Nat :=
  x + x

#print double
#check double 3
#reduce double 3  -- 6
#eval double 3    -- 6

def square (x : Nat) :=
  x * x

#print square
#check square 3
#reduce square 3  -- 9
#eval square 3    -- 9

def doTwice (f : Nat → Nat) (x : Nat) : Nat :=
  f (f x)

#eval doTwice double 2   -- 8
</code></pre>
<p>These definitions are equivalent to the following:</p>
<pre><code class="language-lean">def double : Nat → Nat :=
  fun x =&gt; x + x

def square : Nat → Nat :=
  fun x =&gt; x * x

def doTwice : (Nat → Nat) → Nat → Nat :=
  fun f x =&gt; f (f x)
</code></pre>
<p>We can even use this approach to specify arguments that are types:</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<h2><a class="header" href="#what-makes-dependent-type-theory-dependent" id="what-makes-dependent-type-theory-dependent">What makes dependent type theory dependent?</a></h2>
<p>The short explanation is that what makes dependent type theory dependent is that types can depend on parameters.
You have already seen a nice example of this: the type <code>List α</code> depends on the argument <code>α</code>, and
this dependence is what distinguishes <code>List Nat</code> and <code>List Bool</code>.
For another example, consider the type <code>Vector α n</code>, the type of vectors of elements of <code>α</code> of length <code>n</code>.
This type depends on <em>two</em> parameters: the type <code>α : Type</code> of the elements in the vector and the length <code>n : Nat</code>.</p>
<p>Suppose we wish to write a function <code>cons</code> which inserts a new element at the head of a list.
What type should <code>cons</code> have? Such a function is <em>polymorphic</em>: we expect the <code>cons</code> function for <code>Nat</code>, <code>Bool</code>,
or an arbitrary type <code>α</code> to behave the same way.
So it makes sense to take the type to be the first argument to <code>cons</code>, so that for any type, <code>α</code>, <code>cons α</code>
is the insertion function for lists of type <code>α</code>. In other words, for every <code>α</code>, <code>cons α</code> is the function that takes an element <code>a : α</code>
and a list <code>as : List α</code>, and returns a new list, so we have <code>cons α a as : list α</code>.</p>
<p>It is clear that <code>cons α</code> should have type <code>α → List α → List α</code>. But what type should <code>cons</code> have?
A first guess might be <code>Type → α → list α → list α</code>, but, on reflection, this does not make sense:
the <code>α</code> in this expression does not refer to anything, whereas it should refer to the argument of type <code>Type</code>.
In other words, <em>assuming</em> <code>α : Type</code> is the first argument to the function, the type of the next two elements are <code>α</code> and <code>List α</code>.
These types vary depending on the first argument, <code>α</code>.</p>
<p>This is an instance of a <em>dependent function type</em>, or <em>dependent arrow type</em>. Given <code>α : Type</code> and <code>β : α → Type</code>,
think of <code>β</code> as a family of types over <code>α</code>, that is, a type <code>β a</code> for each <code>a : α</code>.
In that case, the type <code>(a : α) → β a</code> denotes the type of functions <code>f</code> with the property that,
for each <code>a : α</code>, <code>f a</code> is an element of <code>β a</code>. In other words, the type of the value returned by <code>f</code> depends on its input.</p>
<p>Notice that <code>(a : α) → β</code> makes sense for any expression <code>β : Type</code>. When the value of <code>β</code> depends on <code>a</code>
(as does, for example, the expression <code>β a</code> in the previous paragraph), <code>(a : α) → β</code> denotes a dependent function type.
When <code>β</code> doesn't depend on <code>a</code>, <code>(a : α) → β</code> is no different from the type <code>α → β</code>.
Indeed, in dependent type theory (and in Lean), <code>α → β</code> is just notation for <code>(a : α) → β</code> when <code>β</code> does not depend on <code>a</code>.</p>
<p>Returning to the example of lists, we can use the command <code>#check</code> to inspect the type of the following <code>List</code> functions
We will explain the <code>@</code> symbol and the difference between the round and curly braces momentarily.</p>
<pre><code class="language-lean">#check @List.cons    -- {α : Type u_1} → α → List α → List α
#check @List.nil     -- {α : Type u_1} → List α
#check @List.length  -- {α : Type u_1} → List α → Nat
#check @List.append  -- {α : Type u_1} → List α → List α → List α
</code></pre>
<p>Just as dependent function types <code>(a : α) → β a</code> generalize the notion of a function type <code>α → β</code> by allowing <code>β</code> to depend on <code>α</code>,
dependent Cartesian product types <code>(a : α) × β a</code> generalize the Cartesian product <code>α × β</code> in the same way. Dependent products are also
called <em>sigma</em> types, and you can also write them as <code>Σ a : α, β a</code>. You can use <code>⟨a, b⟩</code> or <code>Sigma.mk a b</code> to create a dependent pair.</p>
<pre><code class="language-lean">universes u v

def f (α : Type u) (β : α → Type v) (a : α) (b : β a) : (a : α) × β a :=
  ⟨a, b⟩

def g (α : Type u) (β : α → Type v) (a : α) (b : β a) : Σ a : α, β a :=
  Sigma.mk a b

#reduce f
#reduce g

#reduce f Type (fun α =&gt; α) Nat 10
#reduce g Type (fun α =&gt; α) Nat 10

#reduce (f Type (fun α =&gt; α) Nat 10).1 -- Nat
#reduce (g Type (fun α =&gt; α) Nat 10).1 -- Nat
#reduce (f Type (fun α =&gt; α) Nat 10).2 -- 10
#reduce (g Type (fun α =&gt; α) Nat 10).2 -- 10
</code></pre>
<p>The function <code>f</code> and <code>g</code> above denote the same function.</p>
<h1><a class="header" href="#organizational-features" id="organizational-features">Organizational features</a></h1>
<p>In this section we introduce some organizational features of Lean that are not a part of its kernel per se,
but make it possible to work in the framework more efficiently.</p>
<h1><a class="header" href="#variables-and-sections" id="variables-and-sections">Variables and Sections</a></h1>
<p>Consider the following three function definitions:</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (α : Type) (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (α : Type) (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<p>Lean provides us with the <code>variable</code> command to make such declarations look more compact:</p>
<pre><code class="language-lean">variable (α β γ : Type)

def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

def doTwice (h : α → α) (x : α) : α :=
  h (h x)

def doThrice (h : α → α) (x : α) : α :=
  h (h (h x))
</code></pre>
<p>We can declare variables of any type, not just <code>Type</code> itself:</p>
<pre><code class="language-lean">variable (α β γ : Type)
variable (g : β → γ) (f : α → β) (h : α → α)
variable (x : α)

def compose := g (f x)
def doTwice := h (h x)
def doThrice := h (h (h x))

#print compose
#print doTwice
#print doThrice
</code></pre>
<p>Printing them out shows that all three groups of definitions have exactly the same effect.</p>
<p>The <code>variable</code> command instruct Lean to insert the declared variables as bound variables in definitions that refer to them.
Lean is smart enough to figure out which variables are used explicitly or implicitly in a definition. We can therefore proceed as
though <code>α</code>, <code>β</code>, <code>γ</code>, <code>g</code>, <code>f</code>, <code>h</code>, and <code>x</code> are fixed objects when we write our definitions, and let Lean abstract
the definitions for us automatically.</p>
<p>When declared in this way, a variable stays in scope until the end of the file we are working on.
Sometimes, however, it is useful to limit the scope of a variable. For that purpose, Lean provides the notion of a <code>section</code>:</p>
<pre><code class="language-lean">section useful
  variable (α β γ : Type)
  variable (g : β → γ) (f : α → β) (h : α → α)
  variable (x : α)

  def compose := g (f x)
  def doTwice := h (h x)
  def doThrice := h (h (h x))
end useful
</code></pre>
<p>When the section is closed, the variables go out of scope, and become nothing more than a distant memory.</p>
<p>You do not have to indent the lines within a section. Nor do you have to name a section, which is to say,
you can use an anonymous <code>section</code> / <code>end</code> pair.
If you do name a section, however, you have to close it using the same name.
Sections can also be nested, which allows you to declare new variables incrementally.</p>
<h1><a class="header" href="#namespaces" id="namespaces">Namespaces</a></h1>
<p>Lean provides us with the ability to group definitions into nested, hierarchical <em>namespaces</em>:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
  def ffa : Nat := f (f a)

  #check a
  #check f
  #check fa
  #check ffa
  #check Foo.fa
end Foo

-- #check a  -- error
-- #check f  -- error
#check Foo.a
#check Foo.f
#check Foo.fa
#check Foo.ffa

open Foo

#check a
#check f
#check fa
#check Foo.fa
</code></pre>
<p>When we declare that we are working in the namespace <code>Foo</code>, every identifier we declare has
a full name with prefix &quot;<code>Foo.</code>&quot; Within the namespace, we can refer to identifiers
by their shorter names, but once we end the namespace, we have to use the longer names.</p>
<p>The <code>open</code> command brings the shorter names into the current context. Often, when we import a
module, we will want to open one or more of the namespaces it contains, to have access to the short identifiers.
But sometimes we will want to leave this information hidden, for example, when they conflict with
identifiers in another namespace we want to use. Thus namespaces give us a way to manage our working environment.</p>
<p>For example, Lean groups definitions and theorems involving lists into a namespace <code>List</code>.</p>
<pre><code class="language-lean">#check List.nil
#check List.cons
#check List.map
</code></pre>
<p>We will discuss their types, below. The command <code>open List</code> allows us to use the shorter names:</p>
<pre><code class="language-lean">open List

#check nil
#check cons
#check map
</code></pre>
<p>Like sections, namespaces can be nested:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a

  namespace Bar
    def ffa : Nat := f (f a)

    #check fa
    #check ffa
  end Bar

  #check fa
  #check Bar.ffa
end Foo

#check Foo.fa
#check Foo.Bar.ffa

open Foo

#check fa
#check Bar.ffa
</code></pre>
<p>Namespaces that have been closed can later be reopened, even in another file:</p>
<pre><code class="language-lean">namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
end Foo

#check Foo.a
#check Foo.f

namespace Foo
  def ffa : Nat := f (f a)
end Foo
</code></pre>
<p>Like sections, nested namespaces have to be closed in the order they are opened.
Namespaces and sections serve different purposes: namespaces organize data and sections declare variables for insertion in definitions.
Sections are also useful for delimiting the scope of commands such as <code>set_option</code> and <code>open</code>.</p>
<p>In many respects, however, a <code>namespace ... end</code> block behaves the same as a <code>section ... end</code> block.
In particular, if you use the <code>variable</code> command within a namespace, its scope is limited to the namespace.
Similarly, if you use an <code>open</code> command within a namespace, its effects disappear when the namespace is closed.</p>
<h2><a class="header" href="#implicit-arguments" id="implicit-arguments">Implicit Arguments</a></h2>
<p>Suppose we define the <code>compose</code> function as.</p>
<pre><code class="language-lean">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>The function <code>compose</code> takes three types, <code>α</code>, <code>β</code>, and <code>γ</code>, and two functions, <code>g : β → γ</code> and <code>f : α → β</code>, a value <code>x : α</code>, and
returns <code>g (f x)</code>, the composition of <code>g</code> and <code>f</code>.
We say <code>compose</code> is polymorphic over types <code>α</code>, <code>β</code>, and <code>γ</code>. Now, let's use <code>compose</code>:</p>
<pre><code class="language-lean"><span class="boring">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
</span><span class="boring">  g (f x)
</span>def double (x : Nat) := 2*x
def triple (x : Nat) := 3*x

#check compose Nat Nat Nat double triple 10 -- Nat
#eval  compose Nat Nat Nat double triple 10 -- 60

def appendWorld (s : String) := s ++ &quot;world&quot;
#check String.length -- String → Nat

#check compose String String Nat String.length appendWorld &quot;hello&quot; -- Nat
#eval  compose String String Nat String.length appendWorld &quot;hello&quot; -- 10
</code></pre>
<p>Because <code>compose</code> is polymorphic over types <code>α</code>, <code>β</code>, and <code>γ</code>, we have to provide them in the examples above.
But this information is redundant: one can infer the types from the arguments <code>g</code> and <code>f</code>.
This is a central feature of dependent type theory: terms carry a lot of information, and often some of that information can be inferred from the context.
In Lean, one uses an underscore, <code>_</code>, to specify that the system should fill in the information automatically.</p>
<pre><code class="language-lean"><span class="boring">def compose (α β γ : Type) (g : β → γ) (f : α → β) (x : α) : γ :=
</span><span class="boring"> g (f x)
</span><span class="boring">def double (x : Nat) := 2*x
</span><span class="boring">def triple (x : Nat) := 3*x
</span>#check compose _ _ _ double triple 10 -- Nat
#eval  compose Nat Nat Nat double triple 10 -- 60
<span class="boring">def appendWorld (s : String) := s ++ &quot;world&quot;
</span><span class="boring">#check String.length -- String → Nat
</span>#check compose _ _ _ String.length appendWorld &quot;hello&quot; -- Nat
#eval  compose _ _ _ String.length appendWorld &quot;hello&quot; -- 10
</code></pre>
<p>It is still tedious, however, to type all these underscores. When a function takes an argument that can generally be inferred from context,
Lean allows us to specify that this argument should, by default, be left implicit. This is done by putting the arguments in curly braces, as follows:</p>
<pre><code class="language-lean">def compose {α β γ : Type} (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
<span class="boring">def double (x : Nat) := 2*x
</span><span class="boring">def triple (x : Nat) := 3*x
</span>#check compose double triple 10 -- Nat
#eval  compose double triple 10 -- 60
<span class="boring">def appendWorld (s : String) := s ++ &quot;world&quot;
</span><span class="boring">#check String.length -- String → Nat
</span>#check compose String.length appendWorld &quot;hello&quot; -- Nat
#eval  compose String.length appendWorld &quot;hello&quot; -- 10
</code></pre>
<p>All that has changed are the braces around <code>α β γ: Type</code>.
It makes these three arguments implicit. Notationally, this hides the specification of the type,
making it look as though <code>compose</code> simply takes 3 arguments.</p>
<p>Variables can also be specified as implicit when they are declared with
the <code>variables</code> command:</p>
<pre><code class="language-lean">universe u

section
  variable {α : Type u}
  variable (x : α)
  def ident := x
end

variable (α β : Type u)
variable (a : α) (b : β)

#check ident
#check ident a
#check ident b
</code></pre>
<p>This definition of <code>ident</code> here has the same effect as the one above.</p>
<p>Lean has very complex mechanisms for instantiating implicit arguments, and we will see that they can be used to infer function types, predicates, and even proofs.
The process of instantiating these &quot;holes,&quot; or &quot;placeholders,&quot; in a term is part of a bigger process called <em>elaboration</em>.
The presence of implicit arguments means that at times there may be insufficient information to fix the meaning of an expression precisely.
An expression like <code>ident</code> is said to be <em>polymorphic</em>, because it can take on different meanings in different contexts.</p>
<p>One can always specify the type <code>T</code> of an expression <code>e</code> by writing <code>(e : T)</code>.
This instructs Lean's elaborator to use the value <code>T</code> as the type of <code>e</code> when trying to elaborate it.
In the following example, this mechanism is used to specify the desired types of the expressions <code>ident</code>.</p>
<pre><code class="language-lean">def ident {α : Type u} (a : α) : α := a

#check (ident : Nat → Nat) -- Nat → Nat
</code></pre>
<p>Numerals are overloaded in Lean, but when the type of a numeral cannot be inferred, Lean assumes, by default, that it is a natural number.
So the expressions in the first two <code>#check</code> commands below are elaborated in the same way, whereas the third <code>#check</code> command interprets <code>2</code> as an integer.</p>
<pre><code class="language-lean">#check 2         -- Nat
#check (2 : Nat) -- Nat
#check (2 : Int) -- Int
</code></pre>
<p>Sometimes, however, we may find ourselves in a situation where we have declared an argument to a function to be implicit,
but now want to provide the argument explicitly. If <code>foo</code> is such a function, the notation <code>@foo</code> denotes the same function with all
the arguments made explicit.</p>
<pre><code class="language-lean"><span class="boring">def ident {α : Type u} (a : α) : α := a
</span>variable (α β : Type)

#check @ident           -- {α : Type u} → α → α
#check @ident α         -- α → α
#check @ident β         -- β → β
#check @ident Nat       -- Nat → Nat
#check @ident Bool true -- Bool
</code></pre>
<p>Notice that now the first <code>#check</code> command gives the type of the identifier, <code>ident</code>, without inserting any placeholders.
Moreover, the output indicates that the first argument is implicit.</p>
<p>Named arguments enable you to specify an argument for a parameter by matching the argument with
its name rather than with its position in the parameter list. You can use them to specify explicit <em>and</em> implicit arguments.
If you don't remember the order of the parameters but know their names, you can send the arguments in any order.
You may also provide the value for an implicit parameter when
Lean failed to infer it. Named arguments also improve the readability of your code by identifying what
each argument represents.</p>
<pre><code class="language-lean"><span class="boring">def ident {α : Type u} (a : α) : α := a
</span>
#check ident (α := Nat)  -- Nat → Nat
#check ident (α := Bool) -- Bool → Bool
</code></pre>
<h2><a class="header" href="#auto-bound-implicit-arguments" id="auto-bound-implicit-arguments">Auto Bound Implicit Arguments</a></h2>
<p>In the previous section, we have shown how implicit arguments make functions more convenient to use.
However, functions such as <code>compose</code> are still quite verbose to define. Note that the universe
polymorphic <code>compose</code> is even more verbose than the one previously defined.</p>
<pre><code class="language-lean">universes u v w
def compose {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>You can avoid the <code>universe</code> command by providing the universe parameters when defining <code>compose</code>.</p>
<pre><code class="language-lean">def compose.{u, v, w}
            {α : Type u} {β : Type v} {γ : Type w}
            (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)
</code></pre>
<p>Lean 4 supports a new feature called <em>auto bound implicit arguments</em>. It makes functions such as
<code>compose</code> much more convenient to write. When Lean processes the header of a declaration,
any unbound identifier is automatically added as an implicit argument <em>if</em> it is a single lower case or
greek letter. With this feature, we can write <code>compose</code> as</p>
<pre><code class="language-lean">def compose (g : β → γ) (f : α → β) (x : α) : γ :=
  g (f x)

#check @compose
-- {β : Sort u_1} → {γ : Sort u_2} → {α : Sort u_3} → (β → γ) → (α → β) → α → γ
</code></pre>
<p>Note that, Lean inferred a more general type using <code>Sort</code> instead of <code>Type</code>.</p>
<p>Although we love this feature and use it extensively when implementing Lean,
we realize some users may feel uncomfortable with it. Thus, you can disable it using
the command <code>set_option autoBoundImplicitLocal false</code>.</p>
<pre><code class="language-lean">set_option autoBoundImplicitLocal false
/- The following definition produces `unknown identifier` errors -/
-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=
--   g (f x)
</code></pre>
<h1><a class="header" href="#declaring-new-types" id="declaring-new-types">Declaring New Types</a></h1>
<p>In Lean's library, every concrete type other than the universes and every type constructor other than the dependent function type is
an instance of a general family of type constructions known as <em>inductive types</em>. It is remarkable that it is possible to develop
complex programs and formalize mathematics based on nothing more than the type universes, dependent function types,
and inductive types; everything else follows from those.</p>
<p>Intuitively, an inductive type is built up from a specified list of constructors. In Lean, the basic syntax for specifying such a type is as follows:</p>
<pre><code>inductive NewType where
  | constructor_1 : ... → NewType
  | constructor_2 : ... → NewType
  ...
  | constructor_n : ... → NewType
</code></pre>
<p>The intuition is that each constructor specifies a way of building new objects of <code>NewType</code>, possibly from previously constructed values.
The type <code>NewType</code> consists of nothing more than the objects that are constructed in this way.</p>
<p>We will see below that the arguments to the constructors can include objects of type <code>NewType</code>,
subject to a certain &quot;positivity&quot; constraint, which guarantees that elements of <code>NewType</code> are built
from the bottom up. Roughly speaking, each <code>...</code> can be any function type constructed from <code>NewType</code>
and previously defined types, in which <code>NewType</code> appears, if at all, only as the &quot;target&quot; of the function type.</p>
<p>We will provide a number of examples of inductive types. We will also consider slight generalizations of the scheme above,
to mutually defined inductive types, and so-called <em>inductive families</em>.</p>
<p>Every inductive type comes with constructors, which show how to construct an element of the type, and elimination rules,
which show how to &quot;use&quot; an element of the type in another construction.</p>
<h1><a class="header" href="#enumerated-types" id="enumerated-types">Enumerated Types</a></h1>
<p>The simplest kind of inductive type is simply a type with a finite, enumerated list of elements.
The following command declares the enumerated type <code>Weekday</code>.</p>
<pre><code class="language-lean">inductive Weekday where
  | sunday    : Weekday
  | monday    : Weekday
  | tuesday   : Weekday
  | wednesday : Weekday
  | thursday  : Weekday
  | friday    : Weekday
  | saturday  : Weekday
</code></pre>
<p>The <code>Weekday</code> type has 7 constructors/elements. The constructors live in the <code>Weekday</code> namespace
Think of <code>sunday</code>, <code>monday</code>, …, <code>saturday</code> as being distinct elements of <code>Weekday</code>,
with no other distinguishing properties.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span>#check Weekday.sunday   -- Weekday
#check Weekday.monday   -- Weekday
</code></pre>
<p>You can define functions by pattern matching.
The following function converts a <code>Weekday</code> into a natural number.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span>def natOfWeekday (d : Weekday) : Nat :=
  match d with
  | Weekday.sunday    =&gt; 1
  | Weekday.monday    =&gt; 2
  | Weekday.tuesday   =&gt; 3
  | Weekday.wednesday =&gt; 4
  | Weekday.thursday  =&gt; 5
  | Weekday.friday    =&gt; 6
  | Weekday.saturday  =&gt; 7

#eval natOfWeekday Weekday.tuesday -- 3
</code></pre>
<p>It is often useful to group definitions related to a type in a namespace with the same name.
For example, we can put the function above into the <code>Weekday</code> namespace.
We are then allowed to use the shorter name when we open the namespace.</p>
<p>In the following example, we define functions from <code>Weekday</code> to <code>Weekday</code> in the namespace <code>Weekday</code>.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span>namespace Weekday

def next (d : Weekday) : Weekday :=
  match d with
  | sunday    =&gt; monday
  | monday    =&gt; tuesday
  | tuesday   =&gt; wednesday
  | wednesday =&gt; thursday
  | thursday  =&gt; friday
  | friday    =&gt; saturday
  | saturday  =&gt; sunday

end Weekday
</code></pre>
<p>It is so common to start a definition with a <code>match</code> in Lean, that Lean provides a syntax sugar for it.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span><span class="boring">namespace Weekday
</span>def previous : Weekday -&gt; Weekday
  | sunday    =&gt; saturday
  | monday    =&gt; sunday
  | tuesday   =&gt; monday
  | wednesday =&gt; tuesday
  | thursday  =&gt; wednesday
  | friday    =&gt; thursday
  | saturday  =&gt; friday
<span class="boring">end Weekday
</span></code></pre>
<p>We can use the command <code>#eval</code> to test our definitions.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous : Weekday -&gt; Weekday
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>def toString : Weekday -&gt; String
  | sunday    =&gt; &quot;Sunday&quot;
  | monday    =&gt; &quot;Monday&quot;
  | tuesday   =&gt; &quot;Tuesday&quot;
  | wednesday =&gt; &quot;Wednesday&quot;
  | thursday  =&gt; &quot;Thursday&quot;
  | friday    =&gt; &quot;Friday&quot;
  | saturday  =&gt; &quot;Saturday&quot;

#eval toString (next sunday)             -- &quot;Monday&quot;
#eval toString (next tuesday)            -- &quot;Wednesday&quot;
#eval toString (previous wednesday)      -- &quot;Tuesday&quot;
#eval toString (next (previous sunday))  -- &quot;Sunday&quot;
#eval toString (next (previous monday))  -- &quot;Monday&quot;
-- ..
<span class="boring">end Weekday
</span></code></pre>
<p>We can now prove the general theorem that <code>next (previous d) = d</code> for any weekday <code>d</code>.
The idea is to perform a proof by cases using <code>match</code>, and rely on the fact for each constructor both
sides of the equality reduce to the same term.</p>
<pre><code class="language-lean"><span class="boring">inductive Weekday where
</span><span class="boring"> | sunday    : Weekday
</span><span class="boring"> | monday    : Weekday
</span><span class="boring"> | tuesday   : Weekday
</span><span class="boring"> | wednesday : Weekday
</span><span class="boring"> | thursday  : Weekday
</span><span class="boring"> | friday    : Weekday
</span><span class="boring"> | saturday  : Weekday
</span><span class="boring">namespace Weekday
</span><span class="boring">def next (d : Weekday) : Weekday :=
</span><span class="boring"> match d with
</span><span class="boring"> | sunday    =&gt; monday
</span><span class="boring"> | monday    =&gt; tuesday
</span><span class="boring"> | tuesday   =&gt; wednesday
</span><span class="boring"> | wednesday =&gt; thursday
</span><span class="boring"> | thursday  =&gt; friday
</span><span class="boring"> | friday    =&gt; saturday
</span><span class="boring"> | saturday  =&gt; sunday
</span><span class="boring">def previous : Weekday -&gt; Weekday
</span><span class="boring"> | sunday    =&gt; saturday
</span><span class="boring"> | monday    =&gt; sunday
</span><span class="boring"> | tuesday   =&gt; monday
</span><span class="boring"> | wednesday =&gt; tuesday
</span><span class="boring"> | thursday  =&gt; wednesday
</span><span class="boring"> | friday    =&gt; thursday
</span><span class="boring"> | saturday  =&gt; friday
</span>theorem nextOfPrevious (d : Weekday) : next (previous d) = d :=
  match d with
  | sunday    =&gt; rfl
  | monday    =&gt; rfl
  | tuesday   =&gt; rfl
  | wednesday =&gt; rfl
  | thursday  =&gt; rfl
  | friday    =&gt; rfl
  | saturday  =&gt; rfl
<span class="boring">end Weekday
</span></code></pre>
<h1><a class="header" href="#inductive-types" id="inductive-types">Inductive Types</a></h1>
<p>TODO</p>
<h1><a class="header" href="#structures" id="structures">Structures</a></h1>
<p>Structure is a special case of inductive datatype. It has only one constructor and is not recursive.
Similar to the <code>inductive</code> command, the <code>structure</code> command introduces a namespace with the same name.
The general form is as follows:</p>
<pre><code>structure &lt;name&gt; &lt;parameters&gt; &lt;parent-structures&gt; where
  &lt;constructor-name&gt; :: &lt;fields&gt;
</code></pre>
<p>Most parts are optional. Here is our first example.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α
</code></pre>
<p>In the example above, the constructor name is not provided. So, the constructor is named <code>mk</code> by Lean.
Values of type <code>Point</code> are created using <code>Point.mk a b</code> or <code>{ x := a, y := b : Point α }</code>. The latter can be
written as <code>{ x := a, y := b }</code> when the expected type is known.
The fields of a point <code>p</code> are accessed using <code>Point.x p</code> and <code>Point.y p</code>. You can also the more compact notation <code>p.x</code> and <code>p.y</code> as a shorthand
for <code>Point.x p</code> and <code>Point.y p</code>.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>#check Point
#check Point       -- Type u -&gt; Type u
#check @Point.mk   -- {α : Type u} → α → α → Point α
#check @Point.x    -- {α : Type u} → Point α → α
#check @Point.y    -- {α : Type u} → Point α → α

#check Point.mk 10 20                   -- Point Nat
#check { x := 10, y := 20 : Point Nat } -- Point Nat

def mkPoint (a : Nat) : Point Nat :=
  { x := a, y := a }

#eval (Point.mk 10 20).x                   -- 10
#eval (Point.mk 10 20).y                   -- 20
#eval { x := 10, y := 20 : Point Nat }.x   -- 10
#eval { x := 10, y := 20 : Point Nat }.y   -- 20

def addXY (p : Point Nat) : Nat :=
  p.x + p.y

#eval addXY { x := 10, y := 20 }    -- 30
</code></pre>
<p>In the notation <code>{ ... }</code>, if the fields are in different lines, the <code>,</code> is optional.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def mkPoint (a : Nat) : Point Nat := {
  x := a
  y := a
}
</code></pre>
<p>You can also use <code>where</code> instead of <code>:= { ... }</code>.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>def mkPoint (a : Nat) : Point Nat where
  x := a
  y := a
</code></pre>
<p>Here are some simple theorems about our <code>Point</code> type.</p>
<pre><code class="language-lean"><span class="boring">structure Point (α : Type u) where
</span><span class="boring"> x : α
</span><span class="boring"> y : α
</span>theorem ex1 (a b : α) : (Point.mk a b).x = a :=
  rfl

theorem ex2 (a b : α) : (Point.mk a b).y = b :=
  rfl

theorem ex3 (a b : α) : Point.mk a b = { x := a, y := b } :=
  rfl
</code></pre>
<p>The dot notation is convenient not just for accessing the projections of a structure,
but also for applying functions defined in a namespace with the same name.
If <code>p</code> has type <code>Point</code>, the expression <code>p.foo</code> is interpreted as <code>Point.foo p</code>,
assuming that the first argument to <code>foo</code> has type <code>Point</code>.
The expression <code>p.add q</code> is therefore shorthand for <code>Point.add p q</code> in the example below.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

def Point.add (p q : Point Nat) : Point Nat :=
  { x := p.x + q.x, y := p.y + q.y }

def p : Point Nat := Point.mk 1 2
def q : Point Nat := Point.mk 3 4

#eval (p.add q).x  -- 4
#eval (p.add q).y  -- 6
</code></pre>
<p>After we introduce type classes, we show how to define a function like <code>add</code> so that
it works generically for elements of <code>Point α</code> rather than just <code>Point Nat</code>,
assuming <code>α</code> has an associated addition operation.</p>
<p>More generally, given an expression <code>p.foo x y z</code>, Lean will insert <code>p</code> at the first argument to <code>foo</code> of type <code>Point</code>.
For example, with the definition of scalar multiplication below, <code>p.smul 3</code> is interpreted as <code>Point.smul 3 p</code>.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

def Point.smul (n : Nat) (p : Point Nat) :=
  Point.mk (n * p.x) (n * p.y)

def p : Point Nat :=
  Point.mk 1 2

#eval (p.smul 3).x -- 3
#eval (p.smul 3).y -- 6
</code></pre>
<h2><a class="header" href="#inheritance" id="inheritance">Inheritance</a></h2>
<p>We can <em>extend</em> existing structures by adding new fields. This feature allows us to simulate a form of <em>inheritance</em>.</p>
<pre><code class="language-lean">structure Point (α : Type u) where
  x : α
  y : α

inductive Color where
  | red
  | green
  | blue

structure ColorPoint (α : Type u) extends Point α where
  color : Color

#check { x := 10, y := 20, color := Color.red : ColorPoint Nat }
-- { toPoint := { x := 10, y := 20 }, color := Color.red }
</code></pre>
<p>The output for the <code>check</code> command above suggests how Lean encoded inheritance and multiple inheritance.
Lean uses fields to each parent structure.</p>
<pre><code class="language-lean">structure Foo where
  x : Nat
  y : Nat

structure Boo where
  w : Nat
  z : Nat

structure Bla extends Foo, Boo where
  bit : Bool

#check Bla.mk -- Foo → Boo → Bool → Bla
#check Bla.mk { x := 10, y := 20 } { w := 30, z := 40 } true
#check { x := 10, y := 20, w := 30, z := 40, bit := true : Bla }
#check { toFoo := { x := 10, y := 20 },
         toBoo := { w := 30, z := 40 },
         bit := true : Bla }

theorem ex :
    Bla.mk { x := x, y := y } { w := w, z := z } b
    =
    { x := x, y := y, w := w, z := z, bit := b } :=
  rfl
</code></pre>
<h2><a class="header" href="#default-field-values" id="default-field-values">Default field values</a></h2>
<p>You can assign default value to fields when declaring a new structure.</p>
<pre><code class="language-lean">inductive MessageSeverity
  | error | warning

structure Message where
  fileName : String
  pos      : Option Nat      := none
  severity : MessageSeverity := MessageSeverity.error
  caption  : String          := &quot;&quot;
  data     : String

def msg1 : Message :=
  { fileName := &quot;foo.lean&quot;, data := &quot;failed to import file&quot; }

#eval msg1.pos      -- none
#eval msg1.fileName -- &quot;foo.lean&quot;
#eval msg1.caption  -- &quot;&quot;
</code></pre>
<p>When extending a structure, you can not only add new fields, but provide new default values for existing fields.</p>
<pre><code class="language-lean"><span class="boring">inductive MessageSeverity
</span><span class="boring"> | error | warning
</span><span class="boring">structure Message where
</span><span class="boring"> fileName : String
</span><span class="boring"> pos      : Option Nat      := none
</span><span class="boring"> severity : MessageSeverity := MessageSeverity.error
</span><span class="boring"> caption  : String          := &quot;&quot;
</span><span class="boring"> data     : String
</span>structure MessageExt extends Message where
  timestamp : Nat
  caption   := &quot;extended&quot; -- new default value for field `caption`

def msg2 : MessageExt where
  fileName  := &quot;bar.lean&quot;
  data      := &quot;error at initialization&quot;
  timestamp := 10

#eval msg2.fileName  -- &quot;bar.lean&quot;
#eval msg2.timestamp -- 10
#eval msg2.caption   -- &quot;extended&quot;
</code></pre>
<h2><a class="header" href="#updating-structure-fields" id="updating-structure-fields">Updating structure fields</a></h2>
<p>TODO</p>
<h1><a class="header" href="#type-classes" id="type-classes">Type classes</a></h1>
<p>Typeclasses were introduced as a principled way of enabling
ad-hoc polymorphism in functional programming languages. We first observe that it
would be easy to implement an ad-hoc polymorphic function (such as addition) if the
function simply took the type-specific implementation of addition as an argument
and then called that implementation on the remaining arguments. For example,
suppose we declare a structure in Lean to hold implementations of addition</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>structure Add (a : Type) where
  add : a -&gt; a -&gt; a

#check @Add.add
-- Add.add : {a : Type} → Add a → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>In the above Lean code, the field <code>add</code> has type
<code>Add.add : {α : Type} → Add α → α → α → α</code>
where the curly braces around the type <code>a</code> mean that it is an implicit argument.
We could implement <code>double</code> by</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">structure Add (a : Type) where
</span><span class="boring"> add : a -&gt; a -&gt; a
</span>def double (s : Add a) (x : a) : a :=
  s.add x x

#eval double { add := Nat.add } 10
-- 20

#eval double { add := Nat.mul } 10
-- 100

#eval double { add := Int.add } 10
-- 20

<span class="boring">end Ex
</span></code></pre>
<p>Note that you can double a natural number <code>n</code> by <code>double { add := Nat.add } n</code>.
Of course, it would be highly cumbersome for users to manually pass the
implementations around in this way.
Indeed, it would defeat most of the potential benefits of ad-hoc
polymorphism.</p>
<p>The main idea behind typeclasses is to make arguments such as <code>Add a</code> implicit,
and to use a database of user-defined instances to synthesize the desired instances
automatically through a process known as typeclass resolution. In Lean, by changing
<code>structure</code> to <code>class</code> in the example above, the type of <code>Add.add</code> becomes</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Add (a : Type) where
  add : a -&gt; a -&gt; a

#check @Add.add
-- Add.add : {a : Type} → [self : Add a] → a → a → a
<span class="boring">end Ex
</span></code></pre>
<p>where the square brackets indicate that the argument of type <code>Add a</code> is <em>instance implicit</em>,
i.e. that it should be synthesized using typeclass resolution. This version of
<code>add</code> is the Lean analogue of the Haskell term <code>add :: Add a =&gt; a -&gt; a -&gt; a</code>.
Similarly, we can register an instance by</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Add (a : Type) where
</span><span class="boring"> add : a -&gt; a -&gt; a
</span>instance : Add Nat where
  add := Nat.add

<span class="boring">end Ex
</span></code></pre>
<p>Then for <code>n : Nat</code> and <code>m : Nat</code>, the term <code>Add.add n m</code> triggers typeclass resolution with the goal
of <code>Add Nat</code>, and typeclass resolution will synthesize the instance above. In
general, instances may depend on other instances in complicated ways. For example,
you can declare an (anonymous) instance stating that if <code>a</code> has addition, then <code>Array a</code>
has addition:</p>
<pre><code class="language-lean">instance [Add a] : Add (Array a) where
  add x y := Array.zipWith x y (. + .)

#eval Add.add #[1, 2] #[3, 4]
-- #[4, 6]

#eval #[1, 2] + #[3, 4]
-- #[4, 6]
</code></pre>
<p>Note that <code>x + y</code> is notation for <code>Add.add x y</code> in Lean.</p>
<p>The example above demonstrates how type classes are used to overload notation.
Now, we explore another application. We often need an arbitrary element of a given type.
Recall that types may not have any elements in Lean.
It often happens that we would like a definition to return an arbitrary element in a &quot;corner case.&quot;
For example, we may like the expression <code>head xs</code> to be of type <code>a</code> when <code>xs</code> is of type <code>List a</code>.
Similarly, many theorems hold under the additional assumption that a type is not empty.
For example, if <code>a</code> is a type, <code>exists x : a, x = x</code> is true only if <code>a</code> is not empty.
The standard library defines a type class <code>Inhabited</code> to enable type class inference to infer a
&quot;default&quot; or &quot;arbitrary&quot; element of an inhabited type.
Let us start with the first step of the program above, declaring an appropriate class:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class Inhabited (a : Type u) where
  default : a

#check @Inhabited.default
-- Inhabited.default : {a : Type u} → [self : Inhabited a] → a
<span class="boring">end Ex
</span></code></pre>
<p>Note <code>Inhabited.default</code> doesn't have any explicit argument.</p>
<p>An element of the class <code>Inhabited a</code> is simply an expression of the form <code>Inhabited.mk x</code>, for some element <code>x : a</code>.
The projection <code>Inhabited.default</code> will allow us to &quot;extract&quot; such an element of <code>a</code> from an element of <code>Inhabited a</code>.
Now we populate the class with some instances:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span>instance : Inhabited Bool where
  default := true

instance : Inhabited Nat where
  default := 0

instance : Inhabited Unit where
  default := ()

instance : Inhabited Prop where
  default := True

#eval (Inhabited.default : Nat)
-- 0

#eval (Inhabited.default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<p>You can use the command <code>export</code> to create the alias <code>default</code> for <code>Inhabited.default</code></p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type _) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">instance : Inhabited Unit where
</span><span class="boring"> default := ()
</span><span class="boring">instance : Inhabited Prop where
</span><span class="boring"> default := True
</span>export Inhabited (default)

#eval (default : Nat)
-- 0

#eval (default : Bool)
-- true
<span class="boring">end Ex
</span></code></pre>
<p>Sometimes we want to think of the default element of a type as being an <em>arbitrary</em> element, whose specific value should not play a role in our proofs.
For that purpose, we can write <code>arbitrary</code> instead of <code>default</code>. We define <code>arbitrary</code> as an <em>opaque</em> constant.
Opaque constants are never unfolded by the type checker.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">export Inhabited (default)
</span>theorem defNatEq0 : (default : Nat) = 0 :=
  rfl

constant arbitrary [Inhabited a] : a :=
  Inhabited.default

-- theorem arbitraryNatEq0 : (arbitrary : Nat) = 0 :=
--   rfl
/-
error: type mismatch
  rfl
has type
  arbitrary = arbitrary
but is expected to have type
  arbitrary = 0
-/
<span class="boring">end Ex
</span></code></pre>
<p>The theorem <code>defNatEq0</code> type checks because the type checker can unfold <code>(default : Nat)</code> and reduce it to <code>0</code>. This is not the case in the theorem <code>arbitraryNatEq0</code> because <code>arbitrary</code> is an opaque constant.</p>
<h2><a class="header" href="#chaining-instances" id="chaining-instances">Chaining Instances</a></h2>
<p>If that were the extent of type class inference, it would not be all that impressive;
it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.
What makes type class inference powerful is that one can <em>chain</em> instances. That is,
an instance declaration can in turn depend on an implicit instance of a type class.
This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.</p>
<p>For example, the following definition shows that if two types <code>a</code> and <code>b</code> are inhabited, then so is their product:</p>
<pre><code class="language-lean">instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (arbitrary, arbitrary)
</code></pre>
<p>With this added to the earlier instance declarations, type class instance can infer, for example, a default element of <code>Nat × Bool</code>:</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">class Inhabited (a : Type u) where
</span><span class="boring"> default : a
</span><span class="boring">instance : Inhabited Bool where
</span><span class="boring"> default := true
</span><span class="boring">instance : Inhabited Nat where
</span><span class="boring"> default := 0
</span><span class="boring">constant arbitrary [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span>instance [Inhabited a] [Inhabited b] : Inhabited (a × b) where
  default := (arbitrary, arbitrary)

#eval (arbitrary : Nat × Bool)
-- (0, true)
<span class="boring">end Ex
</span></code></pre>
<p>Similarly, we can inhabit type function with suitable constant functions:</p>
<pre><code class="language-lean">instance [Inhabited b] : Inhabited (a -&gt; b) where
  default := fun _ =&gt; arbitrary
</code></pre>
<p>As an exercise, try defining default instances for other types, such as <code>List</code> and <code>Sum</code> types.</p>
<p>The Lean standard library contains the definition <code>inferInstance</code>. It has type <code>{α : Sort u} → [i : α] → α</code>,
and is useful for triggering the type class resolution procedure when the expected type is an instance.</p>
<pre><code class="language-lean">#check (inferInstance : Inhabited Nat) -- Inhabited Nat

def foo : Inhabited (Nat × Nat) :=
  inferInstance

theorem ex : foo.default = (arbitrary, arbitrary) :=
  rfl
</code></pre>
<p>You can use the command <code>#print</code> to inspect how simple <code>inferInstance</code> is.</p>
<pre><code class="language-lean">#print inferInstance
</code></pre>
<h2><a class="header" href="#tostring" id="tostring">ToString</a></h2>
<p>The polymorphic method <code>toString</code> has type <code>{α : Type u} → [ToString α] → α → String</code>. You implement the instance
for your own types and use chaining to convert complex values into strings. Lean comes with <code>ToString</code> instances
for most builtin types.</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString p := p.name ++ &quot;@&quot; ++ toString p.age

#eval toString { name := &quot;Leo&quot;, age := 542 : Person }
#eval toString ({ name := &quot;Daniel&quot;, age := 18 : Person }, &quot;hello&quot;)
</code></pre>
<h2><a class="header" href="#numerals" id="numerals">Numerals</a></h2>
<p>Numerals are polymorphic in Lean. You can use a numeral (e.g., <code>2</code>) to denote an element of any type that implements
the type class <code>OfNat</code>.</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#eval (2 : Rational) -- 2/1

#check (2 : Rational) -- Rational
#check (2 : Nat)      -- Nat
</code></pre>
<p>Lean elaborate the terms <code>(2 : Nat)</code> and <code>(2 : Rational)</code> as
<code>OfNat.ofNat Nat 2 (instOfNatNat 2)</code> and
<code>OfNat.ofNat Rational 2 (instOfNatRational 2)</code> respectively.
We say the numerals <code>2</code> occurring in the elaborated terms are <em>raw</em> natural numbers.
You can input the raw natural number <code>2</code> using the macro <code>nat_lit 2</code>.</p>
<pre><code class="language-lean">#check nat_lit 2  -- Nat
</code></pre>
<p>Raw natural numbers are <em>not</em> polymorphic.</p>
<p>The <code>OfNat</code> instance is parametric on the numeral. So, you can define instances for particular numerals.
The second argument is often a variable as in the example above, or a <em>raw</em> natural number.</p>
<pre><code class="language-lean">class Monoid (α : Type u) where
  unit : α
  op   : α → α → α

instance [s : Monoid α] : OfNat α (nat_lit 1) where
  ofNat := s.unit

def getUnit [Monoid α] : α :=
  1
</code></pre>
<h2><a class="header" href="#output-parameters" id="output-parameters">Output parameters</a></h2>
<p>By default, Lean only tries to synthesize an instance <code>Inhabited T</code> when the term <code>T</code> is known and does not
contain missing parts. The following command produces the error
&quot;failed to create type class instance for <code>Inhabited (Nat × ?m.1499)</code>&quot; because the type has a missing part (i.e., the <code>_</code>).</p>
<pre><code class="language-lean">#check_failure (inferInstance : Inhabited (Nat × _))
</code></pre>
<p>You can view the parameter of the type class <code>Inhabited</code> as an <em>input</em> value for the type class synthesizer.
When a type class has multiple parameters, you can mark some of them as output parameters.
Lean will start type class synthesizer even when these parameters have missing parts.
In the following example, we use output parameters to define a <em>heterogeneous</em> polymorphic
multiplication.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Nat (Array Nat) (Array Nat) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3           -- 12
#eval hMul 4 #[2, 3, 4]  -- #[8, 12, 16]
<span class="boring">end Ex
</span></code></pre>
<p>The parameters <code>α</code> and <code>β</code> are considered input parameters and <code>γ</code> an output one.
Given an application <code>hMul a b</code>, after types of <code>a</code> and <code>b</code> are known, the type class
synthesizer is invoked, and the resulting type is obtained from the output parameter <code>γ</code>.
In the example above, we defined two instances. The first one is the homogeneous
multiplication for natural numbers. The second is the scalar multiplication for arrays.
Note that, you chain instances and generalize the second instance.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Nat Nat Nat where
  hMul := Nat.mul

instance : HMul Int Int Int where
  hMul := Int.mul

instance [HMul α β γ] : HMul α (Array β) (Array γ) where
  hMul a bs := bs.map (fun b =&gt; hMul a b)

#eval hMul 4 3                    -- 12
#eval hMul 4 #[2, 3, 4]           -- #[8, 12, 16]
#eval hMul (-2) #[3, -1, 4]       -- #[-6, 2, -8]
#eval hMul 2 #[#[2, 3], #[0, 4]]  -- #[#[4, 6], #[0, 8]]
<span class="boring">end Ex
</span></code></pre>
<p>You can use our new scalar array multiplication instance on arrays of type <code>Array β</code>
with a scalar of type <code>α</code> whenever you have an instance <code>HMul α β γ</code>.
In the last <code>#eval</code>, note that the instance was used twice on an array of arrays.</p>
<h2><a class="header" href="#default-instances" id="default-instances">Default instances</a></h2>
<p>In the class <code>HMul</code>, the parameters <code>α</code> and <code>β</code> are treated as input values.
Thus, type class synthesis only starts after these two types are known. This may often
be too restrictive.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

-- Error &quot;failed to create type class instance for HMul Int ?m.1767 (?m.1797 x)&quot;
#check_failure fun y =&gt; xs.map (fun x =&gt; hMul x y)
<span class="boring">end Ex
</span></code></pre>
<p>The instance <code>HMul</code> is not synthesized by Lean because the type of <code>y</code> has not been provided.
However, it is natural to assume that the type of <code>y</code> and <code>x</code> should be the same in
this kind of situation. We can achieve exactly that using <em>default instances</em>.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

export HMul (hMul)

@[defaultInstance]
instance : HMul Int Int Int where
  hMul := Int.mul

def xs : List Int := [1, 2, 3]

#check fun y =&gt; xs.map (fun x =&gt; hMul x y)  -- Int -&gt; List Int
<span class="boring">end Ex
</span></code></pre>
<p>By tagging the instance above with the attribute <code>defaultInstance</code>, we are instructing Lean
to use this instance on pending type class synthesis problems.
The actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.
Moreover, <code>a+b</code>, <code>a*b</code>, <code>a-b</code>, <code>a/b</code>, and <code>a%b</code> are notations for the heterogeneous versions.
The instance <code>OfNat Nat n</code> is the default instance for the <code>OfNat</code> class. This is why the numeral
<code>2</code> has type <code>Nat</code> when the expected type is not known. You can define default instances with higher
priority to override the builtin ones.</p>
<pre><code class="language-lean">structure Rational where
  num : Int
  den : Nat
  inv : den ≠ 0

@[defaultInstance 1]
instance : OfNat Rational n where
  ofNat := { num := n, den := 1, inv := by decide }

instance : ToString Rational where
  toString r := s!&quot;{r.num}/{r.den}&quot;

#check 2 -- Rational
</code></pre>
<p>Priorities are also useful to control the interaction between different default instances.
For example, suppose <code>xs</code> has type <code>α</code>, when elaboration <code>xs.map (fun x =&gt; 2 * x)</code>, we want the homogeneous instance for multiplication
to have higher priority than the default instance for <code>OfNat</code>. This is particularly important when we have implemented only the instance
<code>HMul α α α</code>, and did not implement <code>HMul Nat α α</code>.
Now, we reveal how the notation <code>a*b</code> is defined in Lean.</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span>class OfNat (α : Type u) (n : Nat) where
  ofNat : α

@[defaultInstance]
instance (n : Nat) : OfNat Nat n where
  ofNat := n

class HMul (α : Type u) (β : Type v) (γ : outParam (Type w)) where
  hMul : α → β → γ

class Mul (α : Type u) where
  mul : α → α → α

@[defaultInstance 10]
instance [Mul α] : HMul α α α where
  hMul a b := Mul.mul a b

infixl:70 &quot; * &quot;  =&gt; HMul.hMul
<span class="boring">end Ex
</span></code></pre>
<p>The <code>Mul</code> class is convenient for types that only implement the homogeneous multiplication.</p>
<h2><a class="header" href="#scoped-instances" id="scoped-instances">Scoped Instances</a></h2>
<p>TODO</p>
<h2><a class="header" href="#local-instances" id="local-instances">Local Instances</a></h2>
<p>TODO</p>
<h1><a class="header" href="#unification-hints" id="unification-hints">Unification Hints</a></h1>
<p>TODO</p>
<h1><a class="header" href="#builtin-types" id="builtin-types">Builtin Types</a></h1>
<h2><a class="header" href="#numeric-operations" id="numeric-operations">Numeric Operations</a></h2>
<p>Lean supports the basic mathematical operations you’d expect for all of the number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how you’d use each one in a <code>def</code> commands:</p>
<pre><code class="language-lean">-- addition
def sum := 5 + 10

-- subtraction
def difference := 95.5 - 4.3

-- multiplication
def product := 4 * 30

-- division
def quotient := 53.7 / 32.2

-- remainder/modulo
def modulo := 43 % 5
</code></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates to a single value.</p>
<h1><a class="header" href="#natural-numbers" id="natural-numbers">Natural numbers</a></h1>
<p>The <code>Nat</code> type represents the natural numbers, i.e., arbitrary-precision unsigned integers.
There are no overflows.</p>
<pre><code class="language-lean">#eval 100000000000000000 * 200000000000000000000 * 1000000000000000000000
</code></pre>
<p>A numeral is considered to be a <code>Nat</code> if there are no typing constraints.</p>
<pre><code class="language-lean">#check 10    -- Nat
#check id 10 -- Nat

def f (x : Int) : Int :=
  x - 1

#eval f (3 - 5) -- 3 and 5 are `Int` since `f` expects an `Int`.
-- -3
</code></pre>
<p>The operator <code>-</code> for <code>Nat</code> implements truncated subtraction.</p>
<pre><code class="language-lean">#eval 10 - 5 -- 5
#eval 5 - 10 -- 0

theorem ex : 5 - 10 = 0 :=
  rfl

#eval (5:Int) - 10 -- -5
</code></pre>
<p>The operator <code>/</code> for <code>Nat</code> implements Euclidean division.</p>
<pre><code class="language-lean">#eval 10 / 4 -- 2

#check 10.0 / 4.0 -- Float
#eval 10.0 / 4.0  -- 2.5
</code></pre>
<p>As we described in the previous sections, we define the <code>Nat</code> type as an <code>inductive</code> datatype.</p>
<pre><code class="language-lean"><span class="boring">namespace hidden
</span>inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
<span class="boring">end hidden
</span></code></pre>
<p>However, the internal representation of <code>Nat</code> is optimized. Small natural numbers (i.e., &lt; <code>2^63</code> in a 64-bit machine) are
represented by a single machine word. Big numbers are implemented using <a href="https://gmplib.org/manual/">GMP</a> numbers.
We recommend you use fixed precision numeric types only in performance critical code.</p>
<p>The Lean kernel has builtin support for the <code>Nat</code> type too, and can efficiently reduce <code>Nat</code> expressions during type checking.</p>
<pre><code class="language-lean">#reduce 100000000000000000 * 200000000000000000000 * 1000000000000000000000

theorem ex
      : 1000000000000000 * 2000000000000000000 = 2000000000000000000000000000000000 :=
  rfl
</code></pre>
<p>The sharp-eyed reader will notice that GMP is part of the Lean kernel trusted code base.
We believe this is not a problem because you can use external type checkers to double-check your developments,
and we consider GMP very trustworthy.
Existing external type checkers for Lean 3 (e.g., <a href="https://github.com/gebner/trepplein">Trepplein</a> and <a href="https://github.com/leanprover/tc">TC</a>)
can be easily adapted to Lean 4.
If you are still concerned after checking your development with multiple different external checkers because
they may all rely on buggy arbitrary-precision libraries,
you can develop your own certified arbitrary-precision library and use it to implement your own type checker for Lean.</p>
<h1><a class="header" href="#integers" id="integers">Integers</a></h1>
<p>The <code>Int</code> type represents the arbitrary-precision integers. There are no overflows.</p>
<pre><code class="language-lean">#eval (100000000000000000 : Int) * 200000000000000000000 * 1000000000000000000000
</code></pre>
<p>Recall that nonnegative numerals are considered to be a <code>Nat</code> if there are no typing constraints.</p>
<pre><code class="language-lean">#check 1 -- Nat
#check -1 -- Int
#check (1:Int) -- Int
</code></pre>
<p>The operator <code>/</code> for <code>Int</code> implements integer division.</p>
<pre><code class="language-lean">#eval -10 / 4 -- -2
</code></pre>
<p>Similar to <code>Nat</code>, the internal representation of <code>Int</code> is optimized. Small integers are
represented by a single machine word. Big integers are implemented using <a href="https://gmplib.org/manual/">GMP</a> numbers.
We recommend you use fixed precision numeric types only in performance critical code.</p>
<p>The Lean kernel does not have special support for reducing <code>Int</code> during type checking.
However, since <code>Int</code> is defined as</p>
<pre><code class="language-lean"><span class="boring">namespace hidden
</span>inductive Int : Type where
  | ofNat   : Nat → Int
  | negSucc : Nat → Int
<span class="boring">end hidden
</span></code></pre>
<p>the type checker will be able reduce <code>Int</code> expressions efficiently by relying on the special support for <code>Nat</code>.</p>
<pre><code class="language-lean">theorem ex : -2000000000 * 1000000000 = -2000000000000000000 :=
 rfl
</code></pre>
<h1><a class="header" href="#fixed-precision-unsigned-integers" id="fixed-precision-unsigned-integers">Fixed precision unsigned integers</a></h1>
<h1><a class="header" href="#float" id="float">Float</a></h1>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>The <code>Array</code> type implements a <em>dynamic</em> (aka growable) array.
It is defined as</p>
<pre><code class="language-lean"><span class="boring">namespace hidden
</span>structure Array (α : Type u) where
  data : List α
<span class="boring">end hidden
</span></code></pre>
<p>but its execution time representation is optimized, and it is similar to C++ <code>std::vector&lt;T&gt;</code> and Rust <code>Vec&lt;T&gt;</code>.
The Lean type checker has no special support for reducing <code>Array</code>s.</p>
<p>You can create arrays in several ways. You can create a small array by listing consecutive values between
<code>#[</code> and <code>]</code> and separated by commas, as shown in the following examples.</p>
<pre><code class="language-lean">#check #[1, 2, 3] -- Array Nat

#check #[] -- Array ?m
</code></pre>
<p>The type of the array elements is inferred from the literals used and must be consistent.</p>
<pre><code class="language-lean">#check #[&quot;hello&quot;, &quot;world&quot;] -- Array String

-- The following is not valid
#check_failure #[10, &quot;hello&quot;]
</code></pre>
<p>Recall that the command <code>#check_failure &lt;term&gt;</code> only succeeds when the given term is not type correct.</p>
<p>To create an array of size <code>n</code> in which all the elements are initialized to some value <code>a</code>, use <code>mkArray</code>.</p>
<pre><code class="language-lean">#eval mkArray 5 'a'
-- #['a', 'a', 'a', 'a', 'a']
</code></pre>
<h2><a class="header" href="#accessing-elements" id="accessing-elements">Accessing elements</a></h2>
<p>You can access array elements by using brackets (<code>[</code> and <code>]</code>).</p>
<pre><code class="language-lean">#eval #['a', 'b', 'c'][1]
-- 'b'

def getThird (xs : Array Nat) : Nat :=
  xs[2]

#eval getThird #[10, 20, 30, 40]
-- 30
</code></pre>
<p>The bracket operator is whitespace sensitive.</p>
<pre><code class="language-lean">def f (xs : List Nat) : List Nat :=
  xs ++ xs

def as : Array Nat :=
  #[1, 2, 3, 4]

#eval f [1, 2, 3] -- This is a function application

#eval as[2] -- This is an array access
</code></pre>
<h1><a class="header" href="#list" id="list">List</a></h1>
<h1><a class="header" href="#characters" id="characters">Characters</a></h1>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<h1><a class="header" href="#option" id="option">Option</a></h1>
<h1><a class="header" href="#thunks-tasks-and-threads" id="thunks-tasks-and-threads">Thunks, Tasks, and Threads</a></h1>
<p>A <code>Thunk</code> is defined as</p>
<pre><code class="language-lean"><span class="boring">namespace Ex
</span><span class="boring">universe u
</span>structure Thunk (α : Type u) : Type u where
  fn : Unit → α
<span class="boring">end Ex
</span></code></pre>
<p>A <code>Thunk</code> encapsulates a computation without evaluation.
That is, a <code>Thunk</code> stores the way of how the value would be computed.
The Lean runtime has special support for <code>Thunk</code>s. It caches their values
after they are computed for the first time. This feature is useful for implementing
data structures such as lazy lists.
Here is a small example using a <code>Thunk</code>.</p>
<pre><code class="language-lean">def fib : Nat → Nat
  | 0   =&gt; 0
  | 1   =&gt; 1
  | x+2 =&gt; fib (x+1) + fib x

def f (c : Bool) (x : Thunk Nat) : Nat :=
  if c then
    x.get
  else
    0

def g (c : Bool) (x : Nat) : Nat :=
  f c (Thunk.mk (fun _ =&gt; fib x))

#eval g false 1000
</code></pre>
<p>The function <code>f</code> above uses <code>x.get</code> to evaluate the <code>Thunk</code> <code>x</code>.
The expression <code>Thunk.mk (fun _ =&gt; fib x)</code> creates a <code>Thunk</code> for computing <code>fib x</code>.
Note that <code>fib</code> is a very naive function for computing the Fibonacci numbers,
and it would an unreasonable amount of time to compute <code>fib 1000</code>. However, our
test terminates instantaneously because the <code>Thunk</code> is not evaluated when <code>c</code> is <code>false</code>.
Lean has a builtin coercion from any type <code>a</code> to <code>Thunk a</code>. You write the function <code>g</code> above as</p>
<pre><code class="language-lean"><span class="boring">def fib : Nat → Nat
</span><span class="boring"> | 0   =&gt; 0
</span><span class="boring"> | 1   =&gt; 1
</span><span class="boring"> | x+2 =&gt; fib (x+1) + fib x
</span><span class="boring">def f (c : Bool) (x : Thunk Nat) : Nat :=
</span><span class="boring"> if c then
</span><span class="boring">   x.get
</span><span class="boring"> else
</span><span class="boring">   0
</span>def g (c : Bool) (x : Nat) : Nat :=
  f c (fib x)

#eval g false 1000
</code></pre>
<p>In the following example, we use the macro <code>dbg_trace</code> to demonstrate
that the Lean runtime caches the value computed by a <code>Thunk</code>.
We remark that the macro <code>dbg_trace</code> should be use for debugging purposes
only.</p>
<pre><code class="language-lean">def add1 (x : Nat) : Nat :=
  dbg_trace &quot;add1: {x}&quot;
  x + 1

def double (x : Thunk Nat) : Nat :=
  x.get + x.get

def triple (x : Thunk Nat) : Nat :=
  double x + x.get

def test (x : Nat) : Nat :=
  triple (add1 x)

#eval test 2
-- add1: 2
-- 9
</code></pre>
<p>Note that the message <code>add1: 2</code> is printed only once.
Now, consider the same example using <code>Unit -&gt; Nat</code> instead of <code>Thunk Nat</code>.</p>
<pre><code class="language-lean">def add1 (x : Nat) : Nat :=
  dbg_trace &quot;add1: {x}&quot;
  x + 1

def double (x : Unit -&gt; Nat) : Nat :=
  x () + x ()

def triple (x : Unit -&gt; Nat) : Nat :=
  double x + x ()

def test (x : Nat) : Nat :=
  triple (fun _ =&gt; add1 x)

#eval test 2
-- add1: 2
-- add1: 2
-- 9
</code></pre>
<p>Now, the message <code>add1: 2</code> is printed twice.
It may come as a surprise that it was printed twice instead of three times.
As we pointed out, <code>dbg_trace</code> is a macro used for debugging purposes only,
and <code>add1</code> is still considered to be a pure function.
The Lean compiler performs common subexpression elimination when compiling <code>double</code>,
and the produced code for <code>double</code> executes <code>x ()</code> only once instead of twice.
This transformation is safe because <code>x : Unit -&gt; Nat</code> is pure.</p>
<h1><a class="header" href="#task" id="task">Task</a></h1>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Functions are the fundamental unit of program execution in any programming language.
As in other languages, a Lean function has a name, can have parameters and take arguments, and has a body.
Lean also supports functional programming constructs such as treating functions as values,
using unnamed functions in expressions, composition of functions to form new functions,
curried functions, and the implicit definition of functions by way of
the partial application of function arguments.</p>
<p>You define functions by using the <code>def</code> keyword followed by its name, a parameter list, return type and its body.
The parameter list consists of successive parameters that are separated by spaces.
You can specify an explicit type for each parameter.
If you do not specify a specific argument type, the compiler tries to infer the type from the function body.
An error is returned when it cannot be inferred.
The expression that makes up the function body is typically a compound expression consisting of a number of expressions
that culminate in a final expression that is the return value.
The return type is a colon followed by a type and is optional.
If you do not specify the type of the return value explicitly,
the compiler tries to determine the return type from the final expression.</p>
<pre><code class="language-lean">def f x := x + 1
</code></pre>
<p>In the previous example, the function name is <code>f</code>, the argument is <code>x</code>, which has type <code>Nat</code>,
the function body is <code>x + 1</code>, and the return value is of type <code>Nat</code>.
The following example defines the factorial recursive function using pattern matching.</p>
<pre><code class="language-lean">def fact x :=
  match x with
  | 0   =&gt; 1
  | n+1 =&gt; (n+1) * fact n

#eval fact 100
</code></pre>
<p>By default, Lean only accepts total functions. The <code>partial</code> keyword should be used when Lean cannot
establish that a function always terminates.</p>
<pre><code class="language-lean">partial def g (x : Nat) (p : Nat -&gt; Bool) : Nat :=
  if p x then
    x
  else
    g (x+1) p

#eval g 0 (fun x =&gt; x &gt; 10)
</code></pre>
<p>In the previous example, <code>g x p</code> only terminates if there is a <code>y &gt;= x</code> such that <code>p y</code> returns <code>true</code>.
Of course, <code>g 0 (fun x =&gt; false)</code> never terminates.</p>
<h1><a class="header" href="#lambda-expressions" id="lambda-expressions">Lambda expressions</a></h1>
<p>A lambda expression is an unnamed function.
You define lambda expressions by using the <code>fun</code> keyword. A lambda expression resembles a function definition, except that instead of the <code>:=</code> token,
the <code>=&gt;</code> token is used to separate the argument list from the function body. As in a regular function definition,
the argument types can be inferred or specified explicitly, and the return type of the lambda expression is inferred from the type of the
last expression in the body.</p>
<pre><code class="language-lean">def twice (f : Nat -&gt; Nat) (x : Nat) : Nat :=
  f (f x)

#eval twice (fun x =&gt; x + 1) 3
#eval twice (fun (x : Nat) =&gt; x * 2) 3

#eval List.map (fun x =&gt; x + 1) [1, 2, 3]
-- [2, 3, 4]

#eval List.map (fun (x, y) =&gt; x + y) [(1, 2), (3, 4)]
-- [3, 7]
</code></pre>
<h1><a class="header" href="#syntax-sugar-for-simple-lambda-expressions" id="syntax-sugar-for-simple-lambda-expressions">Syntax sugar for simple lambda expressions</a></h1>
<p>Simple functions can be defined using parentheses and <code>.</code> (or <code>·</code>) as a placeholder.</p>
<pre><code class="language-lean">#check (. + 1)
-- fun a =&gt; a + 1
#check (· + 1)
-- fun a =&gt; a + 1
#check (2 - .)
-- fun a =&gt; 2 - a
#eval [1, 2, 3, 4, 5].foldl (. * .) 1
-- 120

def h (x y z : Nat) :=
  x + y + z

#check (h . 1 .)
-- fun a b =&gt; h a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
</code></pre>
<p>In the previous example, the term <code>(·.1)</code> is syntax sugar for <code>fun x =&gt; x.1</code>. Note that, the ASCII version <code>(..1)</code>
is not supported because <code>..</code> is a reserved symbol.</p>
<h1><a class="header" href="#pipelining" id="pipelining">Pipelining</a></h1>
<p>Pipelining enables function calls to be chained together as successive operations. Pipelining works as follows:</p>
<pre><code class="language-lean">def add1 x := x + 1
def times2 x := x * 2

#eval times2 (add1 100)
#eval 100 |&gt; add1 |&gt; times2
#eval times2 &lt;| add1 &lt;| 100
</code></pre>
<p>The result of the previous <code>#eval</code> commands is 202.
The forward pipeline <code>|&gt;</code> operator takes a function and an argument and return a value.
In contrast, the backward pipeline <code>&lt;|</code> operator takes an argument and a function and returns a value.
These operators are useful for minimizing the number of parentheses.</p>
<pre><code class="language-lean">def add1Times3FilterEven (xs : List Nat) :=
  List.filter (. % 2 == 0) (List.map (. * 3) (List.map (. + 1) xs))

#eval add1Times3FilterEven [1, 2, 3, 4]
-- [6, 12]

-- Define the same function using pipes
def add1Times3FilterEven' (xs : List Nat) :=
  xs |&gt; List.map (. + 1) |&gt; List.map (. * 3) |&gt; List.filter (. % 2 == 0)

#eval add1Times3FilterEven' [1, 2, 3, 4]
-- [6, 12]
</code></pre>
<p>Lean also supports the operator <code>|&gt;.</code> which combines forward pipeline <code>|&gt;</code> operator with the <code>.</code> field notation.</p>
<pre><code class="language-lean">-- Define the same function using pipes
def add1Times3FilterEven'' (xs : List Nat) :=
  xs.map (. + 1) |&gt;.map (. * 3) |&gt;.filter (. % 2 == 0)

#eval add1Times3FilterEven'' [1, 2, 3, 4]
-- [6, 12]
</code></pre>
<p>For users familiar with the Haskell programming language,
Lean also supports the notation <code>f $ a</code> for the backward pipeline <code>f &lt;| a</code>.</p>
<h1><a class="header" href="#tactics" id="tactics">Tactics</a></h1>
<p>Tactics are metaprograms, that is, programs that create programs.
Lean is implemented in Lean, you can import its implementation using <code>import Lean</code>.
The <code>Lean</code> package is part of the Lean distribution.
You can use the functions in the <code>Lean</code> package to write your own metaprograms
that automate repetitive tasks when writing programs and proofs.</p>
<p>We provide the <strong>tactic</strong> domain specific language (DSL) for using the tactic framework.
The tactic DSL provides commands for creating terms (and proofs). You
don't need to import the <code>Lean</code> package for using the tactic DSL.
Simple extensions can be implemented using macros. More complex extensions require
the <code>Lean</code> package. Notation used to write Lean terms can be easily lifted to the tactic DSL.</p>
<p>Tactics are instructions that tell Lean how to construct a term or proof.
Tactics operate on holes also known as goals. Each hole represents a missing
part of the term you are trying to build. Internally these holes are represented
as metavariables. They have a type and a local context. The local context contains
all local variables in scope.</p>
<p>In the following example, we prove the same simple theorem using different tactics.
The keyword <code>by</code> instructs Lean to use the tactic DSL to construct a term.
Our initial goal is a hole with type <code>p ∨ q → q ∨ p</code>. The tactic <code>intro h</code>
fills this hole using the term <code>fun h =&gt; ?m</code> where <code>?m</code> is a new hole we need to solve.
This hole has type <code>q ∨ p</code>, and the local context contains <code>h : p ∨ q</code>.
The tactic <code>cases</code> fills the hole using <code>Or.casesOn h (fun h1 =&gt; ?m1) (fun h2 =&gt; ?m2)</code>
where <code>?m1</code> and <code>?m2</code> are new holes. The tactic <code>apply Or.inr</code> fills the hole <code>?m1</code>
with the application <code>Or.inr ?m3</code>, and <code>exact h1</code> fills <code>?m3</code> with <code>h1</code>.
The tactic <code>assumption</code> tries to fill a hole by searching the local context for a term with the same type.</p>
<pre><code class="language-lean">theorem ex1 : p ∨ q → q ∨ p := by
  intro h
  cases h with
  | inl h1 =&gt;
    apply Or.inr
    exact h1
  | inr h2 =&gt;
    apply Or.inl
    assumption

#print ex1
/-
theorem ex1 : {p q : Prop} → p ∨ q → q ∨ p :=
fun {p q : Prop} (h : p ∨ q) =&gt;
  Or.casesOn h (fun (h1 : p) =&gt; Or.inr h1) fun (h2 : q) =&gt; Or.inl h2
-/

-- You can use `match-with` in tactics.
theorem ex2 : p ∨ q → q ∨ p := by
  intro h
  match h with
  | Or.inl _  =&gt; apply Or.inr; assumption
  | Or.inr h2 =&gt; apply Or.inl; exact h2

-- As we have the `fun+match` syntax sugar for terms,
-- we have the `intro+match` syntax sugar
theorem ex3 : p ∨ q → q ∨ p := by
  intro
  | Or.inl h1 =&gt;
    apply Or.inr
    exact h1
  | Or.inr h2 =&gt;
    apply Or.inl
    assumption
</code></pre>
<p>The examples above are all structured, but Lean 4 still supports unstructured
proofs. Unstructured proofs are useful when creating reusable scripts that may
discharge different goals.
Here is an unstructured version of the example above.</p>
<pre><code class="language-lean">theorem ex1 : p ∨ q → q ∨ p := by
  intro h
  cases h
  apply Or.inr
  assumption
  apply Or.inl
  assumption
  done -- fails with an error here if there are unsolvable goals

theorem ex2 : p ∨ q → q ∨ p := by
  intro h
  cases h
  focus -- instructs Lean to `focus` on the first goal,
    apply Or.inr
    assumption
    -- it will fail if there are still unsolvable goals here
  focus
    apply Or.inl
    assumption

theorem ex3 : p ∨ q → q ∨ p := by
  intro h
  cases h
  -- You can still use curly braces and semicolons instead of
  -- whitespace sensitive notation as in the previous example
  { apply Or.inr;
    assumption
    -- It will fail if there are unsolved goals
  }
  { apply Or.inl;
    assumption
  }

-- Many tactics tag subgoals. The tactic `cases` tag goals using constructor names.
-- The tactic `case tag =&gt; tactics` instructs Lean to solve the goal
-- with the matching tag.
theorem ex4 : p ∨ q → q ∨ p := by
  intro h
  cases h
  case inr =&gt;
    apply Or.inl
    assumption
  case inl =&gt;
    apply Or.inr
    assumption

-- Same example for curly braces and semicolons aficionados
theorem ex5 : p ∨ q → q ∨ p := by {
  intro h;
  cases h;
  case inr =&gt; {
    apply Or.inl;
    assumption
  }
  case inl =&gt; {
    apply Or.inr;
    assumption
  }
}
</code></pre>
<h2><a class="header" href="#rewrite" id="rewrite">Rewrite</a></h2>
<p>TODO</p>
<h2><a class="header" href="#pattern-matching" id="pattern-matching">Pattern matching</a></h2>
<p>As a convenience, pattern-matching has been integrated into tactics such as <code>intro</code> and <code>funext</code>.</p>
<pre><code class="language-lean">theorem ex1 : s ∧ q ∧ r → p ∧ r → q ∧ p := by
  intro ⟨_, ⟨hq, _⟩⟩ ⟨hp, _⟩
  exact ⟨hq, hp⟩

theorem ex2 :
    (fun (x : Nat × Nat) (y : Nat × Nat) =&gt; x.1 + y.2)
    =
    (fun (x : Nat × Nat) (z : Nat × Nat) =&gt; z.2 + x.1) := by
  funext (a, b) (c, d)
  show a + d = d + a
  rw [Nat.add_comm]
</code></pre>
<h2><a class="header" href="#induction" id="induction">Induction</a></h2>
<p>The <code>induction</code> tactic now supports user-defined induction principles with
multiple targets (aka major premises).</p>
<pre><code class="language-lean">/-
theorem Nat.mod.inductionOn
      {motive : Nat → Nat → Sort u}
      (x y  : Nat)
      (ind  : ∀ x y, 0 &lt; y ∧ y ≤ x → motive (x - y) y → motive x y)
      (base : ∀ x y, ¬(0 &lt; y ∧ y ≤ x) → motive x y)
      : motive x y :=
-/

theorem ex (x : Nat) {y : Nat} (h : y &gt; 0) : x % y &lt; y := by
  induction x, y using Nat.mod.inductionOn with
  | ind x y h₁ ih =&gt;
    rw [Nat.mod_eq_sub_mod h₁.2]
    exact ih h
  | base x y h₁ =&gt;
     have : ¬ 0 &lt; y ∨ ¬ y ≤ x := Iff.mp (Decidable.notAndIffOrNot ..) h₁
     match this with
     | Or.inl h₁ =&gt; exact absurd h h₁
     | Or.inr h₁ =&gt;
       have hgt : y &gt; x := Nat.gtOfNotLe h₁
       rw [← Nat.mod_eq_of_lt hgt] at hgt
       assumption
</code></pre>
<h2><a class="header" href="#cases" id="cases">Cases</a></h2>
<p>TODO</p>
<h2><a class="header" href="#injection" id="injection">Injection</a></h2>
<p>TODO</p>
<h2><a class="header" href="#dependent-pattern-matching" id="dependent-pattern-matching">Dependent pattern matching</a></h2>
<p>The <code>match-with</code> expression implements dependent pattern matching. You can use it to create concise proofs.</p>
<pre><code class="language-lean">inductive Mem : α → List α → Prop where
  | head (a : α) (as : List α)   : Mem a (a::as)
  | tail (a b : α) (bs : List α) : Mem a bs → Mem a (b::bs)

infix:50 &quot;∈&quot; =&gt; Mem

theorem mem_split {a : α} {as : List α} (h : a ∈ as) : ∃ s t, as = s ++ a :: t :=
  match a, as, h with
  | _, _, Mem.head a bs     =&gt; ⟨[], ⟨bs, rfl⟩⟩
  | _, _, Mem.tail a b bs h =&gt;
    match bs, mem_split h with
    | _, ⟨s, ⟨t, rfl⟩⟩ =&gt; ⟨b::s, ⟨t, List.cons_append .. ▸ rfl⟩⟩
</code></pre>
<p>In the tactic DSL, the right-hand-side of each alternative in a <code>match-with</code> is a sequence of tactics instead of a term.
Here is a similar proof using the tactic DSL.</p>
<pre><code class="language-lean"><span class="boring">inductive Mem : α → List α → Prop where
</span><span class="boring"> | head (a : α) (as : List α)   : Mem a (a::as)
</span><span class="boring"> | tail (a b : α) (bs : List α) : Mem a bs → Mem a (b::bs)
</span><span class="boring">infix:50 &quot;∈&quot; =&gt; Mem
</span>theorem mem_split {a : α} {as : List α} (h : a ∈ as) : ∃ s t, as = s ++ a :: t := by
  match a, as, h with
  | _, _, Mem.head a bs     =&gt; exists []; exists bs; rfl
  | _, _, Mem.tail a b bs h =&gt;
    match bs, mem_split h with
    | _, ⟨s, ⟨t, rfl⟩⟩ =&gt;
      exists b::s; exists t;
      rw [List.cons_append]
</code></pre>
<p>We can use <code>match-with</code> nested in tactics.
Here is a similar proof that uses the <code>induction</code> tactic instead of recursion.</p>
<pre><code class="language-lean"><span class="boring">inductive Mem : α → List α → Prop where
</span><span class="boring"> | head (a : α) (as : List α)   : Mem a (a::as)
</span><span class="boring"> | tail (a b : α) (bs : List α) : Mem a bs → Mem a (b::bs)
</span><span class="boring">infix:50 &quot;∈&quot; =&gt; Mem
</span>theorem mem_split {a : α} {as : List α} (h : a ∈ as) : ∃ s t, as = s ++ a :: t := by
  induction as with
  | nil          =&gt; cases h
  | cons b bs ih =&gt; cases h with
    | head a bs =&gt; exact ⟨[], ⟨bs, rfl⟩⟩
    | tail a b bs h =&gt;
      match bs, ih h with
      | _, ⟨s, ⟨t, rfl⟩⟩ =&gt;
        exists b::s; exists t
        rw [List.cons_append]
</code></pre>
<p>You can create your own notation using existing tactics. In the following example,
we define a simple <code>obtain</code> tactic using macros. We say it is simple because it takes only one
discriminant. Later, we show how to create more complex automation using macros.</p>
<pre><code class="language-lean"><span class="boring">inductive Mem : α → List α → Prop where
</span><span class="boring"> | head (a : α) (as : List α)   : Mem a (a::as)
</span><span class="boring"> | tail (a b : α) (bs : List α) : Mem a bs → Mem a (b::bs)
</span><span class="boring">infix:50 &quot;∈&quot; =&gt; Mem
</span>macro &quot;obtain &quot; p:term &quot; from &quot; d:term : tactic =&gt;
  `(tactic| match $d:term with | $p:term =&gt; ?_)

theorem mem_split {a : α} {as : List α} (h : a ∈ as) : ∃ s t, as = s ++ a :: t := by
  induction as with
  | cons b bs ih =&gt; cases h with
    | tail a b bs h =&gt;
      obtain ⟨s, ⟨t, h⟩⟩ from ih h
      exists b::s; exists t
      rw [h, List.cons_append]
    | head a bs =&gt; exact ⟨[], ⟨bs, rfl⟩⟩
  | nil =&gt; cases h

</code></pre>
<h2><a class="header" href="#extensible-tactics" id="extensible-tactics">Extensible tactics</a></h2>
<p>In the following example, we define the notation <code>triv</code> for the tactic DSL using
the command <code>syntax</code>. Then, we use the command <code>macro_rules</code> to specify what should
be done when <code>triv</code> is used. You can provide different expansions, and the tactic DSL
interpreter will try all of them until one succeeds.</p>
<pre><code class="language-lean">-- Define a new notation for the tactic DSL
syntax &quot;triv&quot; : tactic

macro_rules
  | `(tactic| triv) =&gt; `(tactic| assumption)

theorem ex1 (h : p) : p := by
  triv

-- You cannot prove the following theorem using `triv`
-- theorem ex2 (x : α) : x = x := by
--  triv

-- Let's extend `triv`. The `by` DSL interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules
  | `(tactic| triv) =&gt; `(tactic| rfl)

theorem ex2 (x : α) : x = x := by
  triv

theorem ex3 (x : α) (h : p) : x = x ∧ p := by
  apply And.intro &lt;;&gt; triv
</code></pre>
<h1><a class="header" href="#let-rec" id="let-rec"><code>let-rec</code></a></h1>
<p>You can use <code>let rec</code> to write local recursive functions. We lifted it to the tactic DSL,
and you can use it to create proofs by induction.</p>
<pre><code class="language-lean">theorem length_replicate {α} (n : Nat) (a : α) : (List.replicate n a).length = n := by
  let rec aux (n : Nat) (as : List α)
      : (List.replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; rw [Nat.zero_add]; rfl
    | n+1 =&gt;
      show List.length (List.replicate.loop a n (a::as)) = Nat.succ n + as.length
      rw [aux n, List.length_cons, Nat.add_succ, Nat.succ_add]
  exact aux n []
</code></pre>
<p>You can also introduce auxiliary recursive declarations using <code>where</code> clause after your definition.
Lean converts them into a <code>let rec</code>.</p>
<pre><code class="language-lean">theorem length_replicate {α} (n : Nat) (a : α) : (List.replicate n a).length = n :=
  loop n []
where
  loop n as : (List.replicate.loop a n as).length = n + as.length := by
    match n with
    | 0   =&gt; rw [Nat.zero_add]; rfl
    | n+1 =&gt;
      show List.length (List.replicate.loop a n (a::as)) = Nat.succ n + as.length
      rw [loop n, List.length_cons, Nat.add_succ, Nat.succ_add]
</code></pre>
<h1><a class="header" href="#begin-end-lovers" id="begin-end-lovers"><code>begin-end</code> lovers</a></h1>
<p>If you love Lean 3 <code>begin ... end</code> tactic blocks and commas, you can define this notation
in Lean 4 using macros in a few lines of code.</p>
<pre><code class="language-lean">open Lean in
macro &quot;begin &quot; ts:tactic,*,? &quot;end&quot;%i : term =&gt; do
  -- preserve position of the last token, which is used
  -- as the error position in case of an unfinished proof
  `(by { $[$ts:tactic]* }%$i)

theorem ex1 (x : Nat) : x + 0 = 0 + x :=
  begin
    rw [Nat.zero_add],
    rw [Nat.add_zero],
  end
</code></pre>
<h1><a class="header" href="#syntax-extensions" id="syntax-extensions">Syntax Extensions</a></h1>
<p>Lean's syntax can be extended and customized by users at every level, ranging from basic &quot;mixfix&quot; notations to custom elaborators.
In fact, all builtin syntax is parsed and processed using the same mechanisms and APIs open to users.
In this section, we will describe and explain the various extension points.
Significant syntax extensions already builtin into Lean such as the <a href="./do.html"><code>do</code> notation</a> are described in subsections.</p>
<p>While introducing new notations is a relatively rare feature in programming languages and sometimes even frowned upon because of its potential to obscure code, it is an invaluable tool in formalization for expressing established conventions and notations of the respective field succinctly in code.
Going beyond basic notations, Lean's ability to factor out common boilerplate code into (well-behaved) macros and to embed entire custom domain specific languages (DSLs) to textually encode subproblems efficiently and readably can be of great benefit to both programmers and proof engineers alike.</p>
<h2><a class="header" href="#notations-and-precedence" id="notations-and-precedence">Notations and Precedence</a></h2>
<p>The most basic syntax extension commands allow introducing new (or overloading existing) prefix, infix, and postfix operators.</p>
<pre><code class="language-lean">infixl:65   &quot; + &quot; =&gt; HAdd.hAdd  -- left-associative
infix:50    &quot; = &quot; =&gt; Eq         -- non-associative
infixr:80   &quot; ^ &quot; =&gt; HPow.hPow  -- right-associative
prefix:100  &quot;-&quot;   =&gt; Neg.neg
<span class="boring">set_option quotPrecheck false
</span>postfix:max &quot;⁻¹&quot;  =&gt; Inv.inv
</code></pre>
<p>After the initial command name describing the operator kind (its &quot;fixity&quot;), we give the <em>parsing precedence</em> of the operator preceded by a colon <code>:</code>, then a new or existing token surrounded by double quotes (the whitespace is used for pretty printing), then the function this operator should be translated to after the arrow <code>=&gt;</code>.</p>
<p>The precedence is a natural number describing how &quot;tightly&quot; an operator binds to its arguments, encoding the order of operations.
We can make this more precise by looking at the commands above unfold to:</p>
<pre><code class="language-lean">notation:65 lhs:65 &quot; + &quot; rhs:66 =&gt; HAdd.hAdd lhs rhs
notation:50 lhs:51 &quot; = &quot; rhs:51 =&gt; Eq lhs rhs
notation:80 lhs:81 &quot; ^ &quot; rhs:80 =&gt; HPow.hPow lhs rhs
notation:100 &quot;-&quot; arg:100 =&gt; Neg.neg arg
<span class="boring">set_option quotPrecheck false
</span>notation:1024 arg:1024 &quot;⁻¹&quot; =&gt; Inv.inv arg  -- `max` is a shorthand for precedence 1024
</code></pre>
<p>It turns out that all commands from the first code block are in fact command <em>macros</em> translating to the more general <code>notation</code> command.
We will learn about writing such macros below.
Instead of a single token, the <code>notation</code> command accepts a mixed sequence of tokens and named term placeholders with precedences, which can be referenced on the right-hand side of <code>=&gt;</code> and will be replaced by the respective term parsed at that position.
A placeholder with precedence <code>p</code> accepts only notations with precedence at least <code>p</code> in that place.
Thus the string <code>a + b + c</code> cannot be parsed as the equivalent of <code>a + (b + c)</code> because the right-hand side operand of an <code>infixl</code> notation has precedence one greater than the notation itself.
In contrast, <code>infixr</code> reuses the notation's precedence for the right-hand side operand, so <code>a ^ b ^ c</code> <em>can</em> be parsed as <code>a ^ (b ^ c)</code>.
Note that if we used <code>notation</code> directly to introduce an infix notation like</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:65 lhs:65 &quot; ~ &quot; rhs:65 =&gt; wobble lhs rhs
</code></pre>
<p>where the precedences do not sufficiently determine associativity, Lean's parser will default to right associativity.
More precisely, Lean's parser follows a local <em>longest parse</em> rule in the presence of ambiguous grammars: when parsing the right-hand side of <code>a ~</code> in <code>a ~ b ~ c</code>, it will continue parsing as long as possible (as the current precedence allows), not stopping after <code>b</code> but parsing <code>~ c</code> as well.
Thus the term is equivalent to <code>a ~ (b ~ c)</code>.</p>
<p>As mentioned above, the <code>notation</code> command allows us to define arbitrary <em>mixfix</em> syntax freely mixing tokens and placeholders.</p>
<pre><code class="language-lean"><span class="boring">set_option quotPrecheck false
</span>notation:max &quot;(&quot; e &quot;)&quot; =&gt; e
notation:10 Γ &quot; ⊢ &quot; e &quot; : &quot; τ =&gt; Typing Γ e τ
</code></pre>
<p>Placeholders without precedence default to <code>0</code>, i.e. they accept notations of any precedence in their place.
If two notations overlap, we again apply the longest parse rule:</p>
<pre><code class="language-lean">notation:65 a &quot; + &quot; b:66 &quot; + &quot; c:66 =&gt; a + b - c
#eval 1 + 2 + 3  -- 0
</code></pre>
<p>The new notation is preferred to the binary notation since the latter, before chaining, would stop parsing after <code>1 + 2</code>.
If there are multiple notations accepting the same longest parse, the choice will be delayed until elaboration, which will fail unless exactly one overload is type correct.</p>
<h2><a class="header" href="#syntax-and-macros" id="syntax-and-macros">Syntax and Macros</a></h2>
<h2><a class="header" href="#elaborators" id="elaborators">Elaborators</a></h2>
<h1><a class="header" href="#the-do-notation" id="the-do-notation">The <code>do</code> notation</a></h1>
<p>Lean is a pure functional programming language, but you can write effectful code using the <code>do</code> embedded domain specific language (DSL). The following simple program prints two strings &quot;hello&quot; and &quot;world&quot; in the standard output and terminates with exit code 0. Note that the type of the program is <code>IO UInt32</code>. You can read this type as the type of values that perform input-output effects and produce a value of type <code>UInt32</code>.</p>
<pre><code class="language-lean">def main : IO UInt32 := do
  IO.println &quot;hello&quot;
  IO.println &quot;world&quot;
  return 0
</code></pre>
<p>The type of <code>IO.println</code> is <code>String → IO Unit</code>. That is, it is a function from <code>String</code> to <code>IO Unit</code> which indicates it may perform input-output effects and produce a value of type <code>Unit</code>. We often say that functions that may perform effects are <em>methods</em>.
We also say a method application, such as <code>IO.println &quot;hello&quot;</code> is an <em>action</em>.
Note that the examples above also demonstrates that braceless <code>do</code> blocks are whitespace sensitive.
If you like <code>;</code>s and curly braces, you can write the example above as</p>
<pre><code class="language-lean">def main : IO UInt32 := do {
  IO.println &quot;hello&quot;;
  IO.println &quot;world&quot;;
  return 0;
}
</code></pre>
<p>Semicolons can be used even when curly braces are not used. They are particularly useful when you want to &quot;pack&quot; more than one action in a single line.</p>
<pre><code class="language-lean">def main : IO UInt32 := do
  IO.println &quot;hello&quot;; IO.println &quot;world&quot;
  return 0
</code></pre>
<p>Whitespace sensitivity in programming languages is a controversial topic
among programmers. You should use your own style. We, the Lean developers, <strong>love</strong> the
braceless and semicolon-free style.
We believe it is clean and beautiful.</p>
<p>The <code>do</code> DSL expands into the core Lean language. Let's inspect the different components using the commands <code>#print</code> and <code>#check</code>.</p>
<pre><code class="language-lean"><span class="boring">def main : IO UInt32 := do
</span><span class="boring"> IO.println &quot;hello&quot;
</span><span class="boring"> IO.println &quot;world&quot;
</span><span class="boring"> return 0
</span>
#check IO.println &quot;hello&quot;
-- IO Unit
#print main
-- Output contains the infix operator `&gt;&gt;=` and `pure`
-- The following `set_option` disables notation such as `&gt;&gt;=` in the output
set_option pp.notation false in
#print main
-- Output contains `bind` and `pure`
#print bind
-- bind : {m : Type u → Type v} → [self : Bind m] → {α β : Type u} →
--        m α → (α → m β) → m β
#print pure
-- pure : {m : Type u → Type v} → [self : Pure m] → {α : Type u} →
--        α → m α

-- IO implements the type classes `Bind` and `Pure`.
#check (inferInstance : Bind IO)
#check (inferInstance : Pure IO)
</code></pre>
<p>The types of <code>bind</code> and <code>pure</code> may look daunting at first sight.
They both have many implicit arguments. Let's focus first on the explicit arguments.
<code>bind</code> has two explicit arguments <code>m α</code> and <code>α → m β</code>. The first one should
be viewed as an action with effects <code>m</code> and producing a value of type <code>α</code>.
The second is a function that takes a value of type <code>α</code> and produces an action
with effects <code>m</code> and a value of type <code>β</code>. The result is <code>m β</code>. The method <code>bind</code> is composing
these two actions. We often say <code>bind</code> is an abstract semicolon. The method <code>pure</code> converts
a value <code>α</code> into an action that produces an action <code>m α</code>.</p>
<p>Here is the same function being defined using <code>bind</code> and <code>pure</code> without the <code>do</code> DSL.</p>
<pre><code class="language-lean">def main : IO UInt32 :=
  bind (IO.println &quot;hello&quot;) fun _ =&gt;
  bind (IO.println &quot;world&quot;) fun _ =&gt;
  pure 0
</code></pre>
<p>The notations <code>let x &lt;- action1; action2</code> and <code>let x ← action1; action2</code> are just syntax sugar for <code>bind action1 fun x =&gt; action2</code>.
Here is a small example using it.</p>
<pre><code class="language-lean">def isGreaterThan0 (x : Nat) : IO Bool := do
  IO.println s!&quot;value: {x}&quot;
  return x &gt; 0

def f (x : Nat) : IO Unit := do
  let c &lt;- isGreaterThan0 x
  if c then
    IO.println s!&quot;{x} is greater than 0&quot;
  else
    pure ()

#eval f 10
-- value: 10
-- 10 is greater than 0
</code></pre>
<h2><a class="header" href="#nested-actions" id="nested-actions">Nested actions</a></h2>
<p>Note that we cannot write <code>if isGreaterThan0 x then ... else ...</code> because the condition in a <code>if-then-else</code> is a <strong>pure</strong> value without effects, but <code>isGreaterThan0 x</code> has type <code>IO Bool</code>. You can use the nested action notation to avoid this annoyance. Here is an equivalent definition for <code>f</code> using a nested action.</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f (x : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) then
    IO.println s!&quot;{x} is greater than 0&quot;
  else
    pure ()

#print f
</code></pre>
<p>Lean &quot;lifts&quot; the nested actions and introduces the <code>bind</code> for us.
Here is an example with two nested actions. Note that both actions are executed
even if <code>x = 0</code>.</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) &amp;&amp; (&lt;- isGreaterThan0 y) then
    IO.println s!&quot;{x} and {y} are greater than 0&quot;
  else
    pure ()

#eval f 0 10
-- value: 0
-- value: 10

-- The function `f` above is equivalent to
def g (x y : Nat) : IO Unit := do
  let c1 &lt;- isGreaterThan0 x
  let c2 &lt;- isGreaterThan0 y
  if c1 &amp;&amp; c2 then
    IO.println s!&quot;{x} and {y} are greater than 0&quot;
  else
    pure ()

theorem fgEqual : f = g :=
  rfl -- proof by reflexivity
</code></pre>
<p>Here are two ways to achieve the short-circuit semantics in the example above</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f1 (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x &lt;&amp;&amp;&gt; isGreaterThan0 y) then
    IO.println s!&quot;{x} and {y} are greater than 0&quot;
  else
    pure ()

-- `&lt;&amp;&amp;&gt;` is the effectful version of `&amp;&amp;`
-- Given `x y : IO Bool`, `x &lt;&amp;&amp;&gt; y` : m Bool`
-- It only executes `y` if `x` returns `true`.

#eval f1 0 10
-- value: 0
#eval f1 1 10
-- value: 1
-- value: 10
-- 1 and 10 are greater than 0

def f2 (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) then
    if (&lt;- isGreaterThan0 y) then
      IO.println s!&quot;{x} and {y} are greater than 0&quot;
    else
      pure ()
  else
    pure ()
</code></pre>
<h2><a class="header" href="#if-then-notation" id="if-then-notation"><code>if-then</code> notation</a></h2>
<p>In the <code>do</code> DSL, we can write <code>if c then action</code> as a shorthand for <code>if c then action else pure ()</code>. Here is the method <code>f2</code> using this shorthand.</p>
<pre><code class="language-lean"><span class="boring">def isGreaterThan0 (x : Nat) : IO Bool := do
</span><span class="boring"> IO.println s!&quot;x: {x}&quot;
</span><span class="boring"> return x &gt; 0
</span>
def f2 (x y : Nat) : IO Unit := do
  if (&lt;- isGreaterThan0 x) then
    if (&lt;- isGreaterThan0 y) then
      IO.println s!&quot;{x} and {y} are greater than 0&quot;
</code></pre>
<h2><a class="header" href="#reassignments" id="reassignments">Reassignments</a></h2>
<p>When writing effectful code, it is natural to think imperatively.
For example, suppose we want to create an empty array <code>xs</code>,
add <code>0</code> if some condition holds, add <code>1</code> if another condition holds,
and then print it. In the following example, we use variable
&quot;shadowing&quot; to simulate this kind of &quot;update&quot;.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let xs := #[]
  let xs := if b1 then xs.push 0 else xs
  let xs := if b2 then xs.push 1 else xs
  IO.println xs

#eval f true true
-- #[0, 1]
#eval f false true
-- #[1]
#eval f true false
-- #[0]
#eval f false false
-- #[]
</code></pre>
<p>We can use tuples to simulate updates on multiple variables.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let xs := #[]
  let ys := #[]
  let (xs, ys) := if b1 then (xs.push 0, ys) else (xs, ys.push 0)
  let (xs, ys) := if b2 then (xs.push 1, ys) else (xs, ys.push 1)
  IO.println s!&quot;xs: {xs}, ys: {ys}&quot;

#eval f true false
-- xs: #[0], ys: #[1]
</code></pre>
<p>We can also simulate the control-flow above using <em>join-points</em>.
A join-point is a <code>let</code> that is always tail called and fully applied.
The Lean compiler implements them using <code>goto</code>s.
Here is the same example using join-points.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let jp1 xs ys := IO.println s!&quot;xs: {xs}, ys: {ys}&quot;
  let jp2 xs ys := if b2 then jp1 (xs.push 1) ys else jp1 xs (ys.push 1)
  let xs := #[]
  let ys := #[]
  if b1 then jp2 (xs.push 0) ys else jp2 xs (ys.push 0)

#eval f true false
-- xs: #[0], ys: #[1]
</code></pre>
<p>You can capture complex control-flow using join-points.
The <code>do</code> DSL offers the variable reassignment feature to make this kind of code more comfortable to write. In the following example, the <code>mut</code> modifier at <code>let mut xs := #[]</code> indicates that variable <code>xs</code> can be reassigned. The example contains two reassignments <code>xs := xs.push 0</code> and <code>xs := xs.push 1</code>. The reassignments are compiled using join-points. There is no hidden state being updated.</p>
<pre><code class="language-lean">def f (b1 b2 : Bool) : IO Unit := do
  let mut xs := #[]
  if b1 then xs := xs.push 0
  if b2 then xs := xs.push 1
  IO.println xs

#eval f true true
-- #[0, 1]
</code></pre>
<p>The notation <code>x &lt;- action</code> reassigns <code>x</code> with the value produced by the action. It is equivalent to <code>x := (&lt;- action)</code></p>
<h2><a class="header" href="#iteration" id="iteration">Iteration</a></h2>
<p>The <code>do</code> DSL provides a unified notation for iterating over datastructures. Here are a few examples.</p>
<pre><code class="language-lean">def sum (xs : Array Nat) : IO Nat := do
  let mut s := 0
  for x in xs do
    IO.println s!&quot;x: {x}&quot;
    s := s + x
  return s

#eval sum #[1, 2, 3]
-- x: 1
-- x: 2
-- x: 3
-- 6

-- We can write pure code using the `do` DSL too.
def sum' (xs : Array Nat) : Nat := do
  let mut s := 0
  for x in xs do
    s := s + x
  return s

#eval sum' #[1, 2, 3]
-- 6

def sumEven (xs : Array Nat) : IO Nat := do
  let mut s := 0
  for x in xs do
    if x % 2 == 0 then
      IO.println s!&quot;x: {x}&quot;
      s := s + x
  return s

#eval sumEven #[1, 2, 3, 6]
-- x: 2
-- x: 6
-- 8

def splitEvenOdd (xs : List Nat) : IO Unit := do
  let mut evens := #[]
  let mut odds  := #[]
  for x in xs do
    if x % 2 == 0 then
      evens := evens.push x
    else
      odds := odds.push x
  IO.println s!&quot;evens: {evens}, odds: {odds}&quot;

#eval splitEvenOdd [1, 2, 3, 4]
-- evens: #[2, 4], odds: #[1, 3]

def findNatLessThan (x : Nat) (p : Nat → Bool) : IO Nat := do
  -- [:x] is notation for the range [0, x)
  for i in [:x] do
    if p i then
      return i -- `return` from the `do` block
  throw (IO.userError &quot;value not found&quot;)

#eval findNatLessThan 10 (fun x =&gt; x &gt; 5 &amp;&amp; x % 4 == 0)
-- 8

def sumOddUpTo (xs : List Nat) (threshold : Nat) : IO Nat := do
  let mut s := 0
  for x in xs do
    if x % 2 == 0 then
      continue -- it behaves like the `continue` statement in imperative languages
    IO.println s!&quot;x: {x}&quot;
    s := s + x
    if s &gt; threshold then
      break -- it behave like the `continue` statement in imperative languages
  IO.println s!&quot;result: {s}&quot;
  return s

#eval sumOddUpTo [2, 3, 4, 11, 20, 31, 41, 51, 107] 40
-- x: 3
-- x: 11
-- x: 31
-- result: 45
-- 45
</code></pre>
<p>TODO: describe <code>forIn</code></p>
<h2><a class="header" href="#try-catch" id="try-catch">Try-catch</a></h2>
<p>TODO</p>
<h2><a class="header" href="#pattern-matching-1" id="pattern-matching-1">Pattern matching</a></h2>
<p>TODO</p>
<h2><a class="header" href="#monads" id="monads">Monads</a></h2>
<p>TODO</p>
<h2><a class="header" href="#readert" id="readert">ReaderT</a></h2>
<p>TODO</p>
<h2><a class="header" href="#statet" id="statet">StateT</a></h2>
<p>TODO</p>
<h2><a class="header" href="#statereft" id="statereft">StateRefT</a></h2>
<p>TODO</p>
<h2><a class="header" href="#exceptt" id="exceptt">ExceptT</a></h2>
<p>TODO</p>
<h2><a class="header" href="#monadlift-and-automatic-lifting" id="monadlift-and-automatic-lifting">MonadLift and automatic lifting</a></h2>
<p>TODO</p>
<h1><a class="header" href="#string-interpolation" id="string-interpolation">String interpolation</a></h1>
<p>The <code>s!</code> prefix identifies a string literal as an interpolated string.
An interpolated string is a string literal that might contain interpolation expressions.
When an interpolated string is resolved to a result string, items with interpolation expressions are
replaced by the string representations of the expression results. The polymorphic method <code>toString</code> is used
to convert the value into a string.</p>
<p>String interpolation provides a more readable and convenient syntax to create formatted strings than
a string composite formatting feature. The following example uses both features to produce the same output:</p>
<pre><code class="language-lean">def name := &quot;John&quot;
def age  := 28

#eval IO.println s!&quot;Hello, {name}! Are you {age} years old?&quot;

#eval IO.println (&quot;Hello, &quot; ++ name ++ &quot;! Are you &quot; ++ toString age ++ &quot; years old?&quot;)

-- `println! &lt;interpolated-string&gt;` is a macro for `IO.println s!&lt;interpolated-string&gt;`
#eval println! &quot;Hello, {name}! Are you {age} years old?&quot;
</code></pre>
<h1><a class="header" href="#structure-of-an-interpolated-string" id="structure-of-an-interpolated-string">Structure of an interpolated string</a></h1>
<p>To identify a string literal as an interpolated string, prepend it with <code>s!</code>.
Terms inside braces <code>{}</code> are ordinary expressions whose type implements the type class <code>ToString</code>.
To include a curly brace <code>{</code> in your interpolated string, you must escape it using <code>\{</code>.
You can nest interpolated strings inside interpolated strings.</p>
<pre><code class="language-lean">def vals := [1, 2, 3]

#eval IO.println s!&quot;\{ vals := {vals} }&quot;

#eval IO.println s!&quot;variables: {vals.map (fun i =&gt; s!&quot;x_{i}&quot;)}&quot;
</code></pre>
<h1><a class="header" href="#tostring-instances" id="tostring-instances"><code>ToString</code> instances</a></h1>
<p>You can define a <code>ToString</code> instance for your own datatypes.</p>
<pre><code class="language-lean">structure Person where
  name : String
  age  : Nat

instance : ToString Person where
  toString : Person -&gt; String
    | { name := n, age := v } =&gt; s!&quot;\{ name := {n}, age := {v} }&quot;

def person1 : Person := {
  name := &quot;John&quot;
  age  := 28
}

#eval println! &quot;person1: {person1}&quot;
</code></pre>
<h1><a class="header" href="#frequently-asked-questions" id="frequently-asked-questions">Frequently Asked Questions</a></h1>
<ul>
<li>What is Lean?</li>
</ul>
<p>Lean is a new open source theorem prover being developed at Microsoft Research.
It is a research project that aims to bridge the gap between interactive and automated theorem proving.
Lean can be also used as a programming language. Actually, some Lean features are implemented in Lean itself.</p>
<ul>
<li>Are pull requests welcome?</li>
</ul>
<p>In the past, we accepted most pull requests. This practice produced hard to maintain code, performance problems, and bugs.
It takes time to review a pull request and make sure it is correct, useful and is not in conflict with our plans.
Small bug fixes (few lines of code) are always welcome. Any other kind of unrequested pull request is not.
Thus, before implementing a feature or modifying the system, please ask whether the change is welcome or not.
We have issues tagged with <a href="https://github.com/leanprover/lean4/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22">&quot;help wanted&quot;</a>, if you want to contribute to the project, please take a look at them.
If you are interested in one of them, post comments, ask questions, and engage with the core developers there.</p>
<ul>
<li>Should I use Lean?</li>
</ul>
<p>Lean is under heavy development, and we are constantly trying new
ideas and tweaking the system.  It is a research project and not a product.
Things change rapidly, and we constantly break backward compatibility.
Lean comes &quot;as is&quot;, you should not expect we will fix bugs and/or add new features for your project.
We have our own priorities, and will not change them to accommodate your needs.
Even if you implement a new feature or fix a bug, we may not want to merge it because
it may conflict with our plans for Lean, it may not be performant, we may not want to maintain it,
we may be busy, etc. If you really need this new feature or bug fix, we suggest you create your own fork and maintain it yourself.</p>
<ul>
<li>Where is the documentation?</li>
</ul>
<p>This is the Lean 4 manual. It is a work in progress, but it will eventually cover the whole language.
A public and very active chat room dedicated to Lean is open on <a href="https://leanprover.zulipchat.com">Zulip</a>.
It is a good place to interact with other Lean users.</p>
<ul>
<li>Should I use Lean to teach a course?</li>
</ul>
<p>Lean has been used to teach courses on logic, type theory and programming languages at CMU and the University of Washington.
The lecture notes for the CMU course <a href="https://leanprover.github.io/logic_and_proof">Logic and Proof</a> are available online,
but they are for Lean 3.
If you decide to teach a course using Lean, we suggest you prepare all material before the beginning of the course, and
make sure that Lean attends all your needs. You should not expect we will fix bugs and/or add features needed for your course.</p>
<ul>
<li>Are there IDEs for Lean?</li>
</ul>
<p>Yes, see <a href="./setup.html">Setting Up Lean</a>.</p>
<ul>
<li>Is Lean sound? How big is the kernel? Should I trust it?</li>
</ul>
<p>Lean has a relatively small kernel.
Several independent checkers have been implemented for Lean 3. Two of them are
<a href="https://github.com/leanprover/tc">tc</a> and <a href="https://github.com/gebner/trepplein">trepplein</a>.
We expect similar independent checkers will be built for Lean 4.</p>
<ul>
<li>Should I open a new issue?</li>
</ul>
<p>We use <a href="https://github.com/leanprover/lean4/issues">GitHub</a> to track bugs and new features.
Bug reports are always welcome, but nitpicking issues are not (e.g., the error message is confusing).
RFC issues are created by developers only.</p>
<h1><a class="header" href="#significant-changes-from-lean-3" id="significant-changes-from-lean-3">Significant changes from Lean 3</a></h1>
<p>Lean 4 is not backward compatible with Lean 3.
We have rewritten most of the system, and took the opportunity to cleanup the syntax,
metaprogramming framework, and elaborator. In this section, we go over the most significant
changes.</p>
<h2><a class="header" href="#lambda-expressions-1" id="lambda-expressions-1">Lambda expressions</a></h2>
<p>We do not use <code>,</code> anymore to separate the binders from the lambda expression body.
The Lean 3 syntax for lambda expressions was unconventional, and <code>,</code> has been overused in Lean 3.
For example, we believe a list of lambda expressions is quite confusing in Lean 3, since <code>,</code> is used
to separate the elements of a list, and in the lambda expression itself. We now use <code>=&gt;</code> as the separator,
as an example, <code>fun x =&gt; x</code> is the identity function. One may still use the symbol <code>λ</code> as a shorthand for <code>fun</code>.
The lambda expression notation has many new features that are not supported in Lean 3.</p>
<ul>
<li>Pattern matching</li>
</ul>
<p>In Lean 4, one can easily create new notation that abbreviates commonly used idioms. One of them is a
<code>fun</code> followed by a <code>match</code>. In the following examples, we define a few functions using <code>fun</code>+<code>match</code> notation.</p>
<pre><code class="language-lean"><span class="boring">namespace ex1
</span>def Prod.str : Nat × Nat → String :=
  fun (a, b) =&gt; &quot;(&quot; ++ toString a ++ &quot;, &quot; ++ toString b ++ &quot;)&quot;

structure Point where
  x : Nat
  y : Nat
  z : Nat

def Point.addX : Point → Point → Nat :=
  fun { x := a, .. } { x := b, .. } =&gt;  a+b

def Sum.str : Option Nat → String :=
  fun
    | some a =&gt; &quot;some &quot; ++ toString a
    | none   =&gt; &quot;none&quot;
<span class="boring">end ex1
</span></code></pre>
<ul>
<li>Implicit lambdas</li>
</ul>
<p>In Lean 3 stdlib, we find many <a href="https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39">instances</a> of the dreadful <code>@</code>+<code>_</code> idiom.
It is often used when we the expected type is a function type with implicit arguments,
and we have a constant (<code>reader_t.pure</code> in the example) which also takes implicit arguments. In Lean 4, the elaborator automatically introduces lambdas
for consuming implicit arguments. We are still exploring this feature and analyzing its impact, but the experience so far has been very positive. As an example,
here is the example in the link above using Lean 4 implicit lambdas.</p>
<pre><code class="language-lean"><span class="boring">variable (ρ : Type) (m : Type → Type) [Monad m]
</span>instance : Monad (ReaderT ρ m) where
  pure := ReaderT.pure
  bind := ReaderT.bind
</code></pre>
<p>Users can disable the implicit lambda feature by using <code>@</code> or writing a lambda expression with <code>{}</code> or <code>[]</code> binder annotations.
Here are few examples</p>
<pre><code class="language-lean"><span class="boring">namespace ex2
</span>def id1 : {α : Type} → α → α :=
  fun x =&gt; x

def listId : List ({α : Type} → α → α) :=
  (fun x =&gt; x) :: []

-- In this example, implicit lambda introduction has been disabled because
-- we use `@` before `fun`
def id2 : {α : Type} → α → α :=
  @fun α (x : α) =&gt; id1 x

def id3 : {α : Type} → α → α :=
  @fun α x =&gt; id1 x

def id4 : {α : Type} → α → α :=
  fun x =&gt; id1 x

-- In this example, implicit lambda introduction has been disabled
-- because we used the binder annotation `{...}`
def id5 : {α : Type} → α → α :=
  fun {α} x =&gt; id1 x
<span class="boring">end ex2
</span></code></pre>
<ul>
<li>Sugar for simple functions</li>
</ul>
<p>In Lean 3, we can create simple functions from infix operators by using parentheses. For example, <code>(+1)</code> is sugar for <code>fun x, x + 1</code>. In Lean 4, we generalize this notation using <code>·</code> As a placeholder. Here are a few examples:</p>
<pre><code class="language-lean"><span class="boring">namespace ex3
</span>#check (· + 1)
-- fun a =&gt; a + 1
#check (2 - ·)
-- fun a =&gt; 2 - a
#eval [1, 2, 3, 4, 5].foldl (·*·) 1
-- 120

def f (x y z : Nat) :=
  x + y + z

#check (f · 1 ·)
-- fun a b =&gt; f a 1 b

#eval [(1, 2), (3, 4), (5, 6)].map (·.1)
-- [1, 3, 5]
<span class="boring">end ex3
</span></code></pre>
<p>As in Lean 3, the notation is activated using parentheses, and the lambda abstraction is created by collecting the nested <code>·</code>s.
The collection is interrupted by nested parentheses. In the following example, two different lambda expressions are created.</p>
<pre><code class="language-lean">#check (Prod.mk · (· + 1))
-- fun a =&gt; (a, fun b =&gt; b + 1)
</code></pre>
<h2><a class="header" href="#function-applications" id="function-applications">Function applications</a></h2>
<p>In Lean 4, we have support for named arguments.
Named arguments enable you to specify an argument for a parameter by matching the argument with
its name rather than with its position in the parameter list.
If you don't remember the order of the parameters but know their names,
you can send the arguments in any order. You may also provide the value for an implicit parameter when
Lean failed to infer it. Named arguments also improve the readability of your code by identifying what
each argument represents.</p>
<pre><code class="language-lean">def sum (xs : List Nat) :=
  xs.foldl (init := 0) (·+·)

#eval sum [1, 2, 3, 4]
-- 10

example {a b : Nat} {p : Nat → Nat → Nat → Prop} (h₁ : p a b b) (h₂ : b = a)
    : p a a b :=
  Eq.subst (motive := fun x =&gt; p a x b) h₂ h₁
</code></pre>
<p>In the following examples, we illustrate the interaction between named and default arguments.</p>
<pre><code class="language-lean">def f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) :=
  x + y + w - z

example (x z : Nat) : f (z := z) x = x + 1 + 2 - z := rfl

example (x z : Nat) : f x (z := z) = x + 1 + 2 - z := rfl

example (x y : Nat) : f x y = fun z =&gt; x + y + 2 - z := rfl

example : f = (fun x z =&gt; x + 1 + 2 - z) := rfl

example (x : Nat) : f x = fun z =&gt; x + 1 + 2 - z := rfl

example (y : Nat) : f (y := 5) = fun x z =&gt; x + 5 + 2 - z := rfl

def g {α} [Add α] (a : α) (b? : Option α := none) (c : α) : α :=
  match b? with
  | none   =&gt; a + c
  | some b =&gt; a + b + c

variable {α} [Add α]

example : g = fun (a c : α) =&gt; a + c := rfl

example (x : α) : g (c := x) = fun (a : α) =&gt; a + x := rfl

example (x : α) : g (b? := some x) = fun (a c : α) =&gt; a + x + c := rfl

example (x : α) : g x = fun (c : α) =&gt; x + c := rfl

example (x y : α) : g x y = fun (c : α) =&gt; x + y + c := rfl
</code></pre>
<p>In Lean 4, we can use <code>..</code> to provide missing explicit arguments as <code>_</code>.
This feature combined with named arguments is useful for writing patterns. Here is an example:</p>
<pre><code class="language-lean">inductive Term where
  | var    (name : String)
  | num    (val : Nat)
  | add    (fn : Term) (arg : Term)
  | lambda (name : String) (type : Term) (body : Term)

def getBinderName : Term → Option String
  | Term.lambda (name := n) .. =&gt; some n
  | _ =&gt; none

def getBinderType : Term → Option Term
  | Term.lambda (type := t) .. =&gt; some t
  | _ =&gt; none
</code></pre>
<p>Ellipsis are also useful when explicit argument can be automatically inferred by Lean, and we want
to avoid a sequence of <code>_</code>s.</p>
<pre><code class="language-lean">example (f : Nat → Nat) (a b c : Nat) : f (a + b + c) = f (a + (b + c)) :=
  congrArg f (Nat.add_assoc ..)
</code></pre>
<h2><a class="header" href="#dependent-function-types" id="dependent-function-types">Dependent function types</a></h2>
<p>Given <code>α : Type</code> and <code>β : α → Type</code>, <code>(x : α) → β x</code> denotes the type of functions <code>f</code> with the property that,
for each <code>a : α</code>, <code>f a</code> is an element of <code>β a</code>. In other words, the type of the value returned by <code>f</code> depends on its input.
We say <code>(x : α) → β x</code> is a dependent function type. In Lean 3, we write the dependent function type <code>(x : α) → β x</code> using
one of the following three equivalent notations:
<code>forall x : α, β x</code> or <code>∀ x : α, β x</code> or <code>Π x : α, β x</code>.
The first two were intended to be used for writing propositions, and the latter for writing code.
Although the notation <code>Π x : α, β x</code> has historical significance, we have removed it from Lean 4 because
it is awkward to use and often confuses new users. We can still write <code>forall x : α, β x</code> and <code>∀ x : α, β x</code>.</p>
<pre><code class="language-lean">#check forall (α : Type), α → α
#check ∀ (α : Type), α → α
#check ∀ α : Type, α → α
#check ∀ α, α → α
#check (α : Type) → α → α
#check {α : Type} → (a : Array α) → (i : Nat) → i &lt; a.size → α
#check {α : Type} → [ToString α] → α → String
#check forall {α : Type} (a : Array α) (i : Nat), i &lt; a.size → α
#check {α β : Type} → α → β → α × β
</code></pre>
<h2><a class="header" href="#the-meta-keyword" id="the-meta-keyword">The <code>meta</code> keyword</a></h2>
<p>In Lean 3, the keyword <code>meta</code> is used to mark definitions that can use primitives implemented in C/C++.
These metadefinitions can also call themselves recursively, relaxing the termination
restriction imposed by ordinary type theory. Metadefinitions may also use unsafe primitives such as
<code>eval_expr (α : Type u) [reflected α] : expr → tactic α</code>, or primitives that break referential transparency
<code>tactic.unsafe_run_io</code>.</p>
<p>The keyword <code>meta</code> has been currently removed from Lean 4. However, we may re-introduce it in the future,
but with a much more limited purpose: marking meta code that should not be included in the executables produced by Lean.</p>
<p>The keywords <code>axiom</code> and <code>constant</code> are not equivalent in Lean 4. In Lean 4, <code>constant</code> is used to define
an opaque definition. Here are two simple examples:</p>
<pre><code class="language-lean"><span class="boring">namespace meta1
</span>constant x : Nat := 1
-- The following example will not type check since `x` is opaque
-- example : x = 1 := rfl

-- We can evaluate `x`
#eval x
-- 1

-- When no value is provided, the elaborator tries to build one automatically for us
-- using the `Inhabited` type class
constant y : Nat
<span class="boring">end meta1
</span></code></pre>
<p>We can instruct Lean to use a foreign function as the implementation for any constant or definition
using the attribute <code>@[extern &quot;foreign_function&quot;]</code>. It is the user's responsibility to ensure the
foreign implementation is correct.
However, a user mistake here will only impact the code generated by Lean, and
it will <strong>not</strong> compromise the logical soundness of the system.
That is, you cannot prove <code>False</code> using the <code>@[extern]</code> attribute.
We use <code>@[extern]</code> with definitions when we want to provide a reference implementation in Lean
that can be used for reasoning. When we write a definition such as</p>
<pre><code class="language-lean">@[extern &quot;lean_nat_add&quot;]
def add : Nat → Nat → Nat
  | a, Nat.zero   =&gt; a
  | a, Nat.succ b =&gt; Nat.succ (add a b)
</code></pre>
<p>Lean assumes that the foreign function <code>lean_nat_add</code> implements the reference implementation above.</p>
<p>The <code>unsafe</code> keyword allows us to define functions using unsafe features such as general recursion,
and arbitrary type casting. Regular (safe) functions cannot directly use <code>unsafe</code> ones since it would
compromise the logical soundness of the system. As in regular programming languages, programs written
using unsafe features may crash at runtime. Here are a few unsafe examples:</p>
<pre><code class="language-lean">unsafe def unsound : False :=
  unsound

#check @unsafeCast
-- {α : Type _} → {β : Type _} → α → β

unsafe def nat2String (x : Nat) : String :=
  unsafeCast x

-- The following definition doesn't type check because it is not marked as `unsafe`
-- def nat2StringSafe (x : Nat) : String :=
--   unsafeCast x
</code></pre>
<p>The <code>unsafe</code> keyword is particularly useful when we want to take advantage of an implementation detail of the
Lean execution runtime. For example, we cannot prove in Lean that arrays have a maximum size, but
the runtime used to execute Lean programs guarantees that an array cannot have more than 2^64 (2^32) elements
in a 64-bit (32-bit) machine. We can take advantage of this fact to provide a more efficient implementation for
array functions. However, the efficient version would not be very useful if it can only be used in
unsafe code. Thus, Lean 4 provides the attribute <code>@[implementedBy functionName]</code>. The idea is to provide
an unsafe (and potentially more efficient) version of a safe definition or constant. The function <code>f</code>
at the attribute <code>@[implementedBy f]</code> is very similar to an extern/foreign function,
the key difference is that it is implemented in Lean itself. Again, the logical soundness of the system
cannot be compromised by using the attribute <code>implementedBy</code>, but if the implementation is incorrect your
program may crash at runtime. In the following example, we define <code>withPtrUnsafe a k h</code> which
executes <code>k</code> using the memory address where <code>a</code> is stored in memory. The argument <code>h</code> is proof
that <code>k</code> is a constant function. Then, we &quot;seal&quot; this unsafe implementation at <code>withPtr</code>. The proof <code>h</code>
ensures the reference implementation <code>k 0</code> is correct. For more information, see the article
&quot;Sealing Pointer-Based Optimizations Behind Pure Functions&quot;.</p>
<pre><code class="language-lean">unsafe
def withPtrUnsafe {α β : Type} (a : α) (k : USize → β) (h : ∀ u, k u = k 0) : β :=
  k (ptrAddrUnsafe a)

@[implementedBy withPtrUnsafe]
def withPtr {α β : Type} (a : α) (k : USize → β) (h : ∀ u, k u = k 0) : β :=
  k 0
</code></pre>
<p>General recursion is very useful in practice, and it would be impossible to implement Lean 4 without it.
The keyword <code>partial</code> implements a very simple and efficient approach for supporting general recursion.
Simplicity was key here because of the bootstrapping problem. That is, we had to implement Lean in Lean before
many of its features were implemented (e.g., the tactic framework or support for wellfounded recursion).
Another requirement for us was performance. Functions tagged with <code>partial</code> should be as efficient as the ones implemented in mainstream functional programming
languages such as OCaml. When the <code>partial</code> keyword is used, Lean generates an auxiliary <code>unsafe</code> definition that
uses general recursion, and then defines an opaque constant that is implemented by this auxiliary definition.
This is very simple, efficient, and is sufficient for users that want to use Lean as a regular programming language.
A <code>partial</code> definition cannot use unsafe features such as <code>unsafeCast</code> and <code>ptrAddrUnsafe</code>, and it can only be used to
implement types we already known to be inhabited. Finally, since we &quot;seal&quot; the auxiliary definition using an opaque
constant, we cannot reason about <code>partial</code> definitions.</p>
<p>We are aware that proof assistants such as Isabelle provide a framework for defining partial functions that does not
prevent users from proving properties about them. This kind of framework can be implemented in Lean 4. Actually,
it can be implemented by users since Lean 4 is an extensible system. The developers current have no plans to implement
this kind of support for Lean 4. However, we remark that users can implement it using a function that traverses
the auxiliary unsafe definition generated by Lean, and produces a safe one using an approach similar to the one used in Isabelle.</p>
<pre><code class="language-lean"><span class="boring">namespace partial1
</span>partial def f (x : Nat) : IO Unit := do
  IO.println x
  if x &lt; 100 then
     f (x+1)

#eval f 98
<span class="boring">end partial1
</span></code></pre>
<p>The <a href="https://pygments.org/">Pygments</a> syntax highlighting library has official support for Lean (however, Lean 4 keywords have not been added yet), which can be used in LaTeX via the <a href="https://ctan.org/pkg/minted"><code>minted</code></a> package.</p>
<h1><a class="header" href="#example" id="example">Example</a></h1>
<p>Save the following sample LaTeX file as <code>test.tex</code>:</p>
<pre><code class="language-latex">\documentclass{article}
\usepackage{minted}
\usepackage{fontspec}
\setmainfont{FreeSerif}
\setmonofont{FreeMono}
\usepackage{fullpage}
\begin{document}
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               frame=lines,
               framesep=2mm]{Lean}
theorem mul_cancel_left_or {a b c : ℤ} (H : a * b = a * c) : a = 0 ∨ b = c :=
have H2 : a * (b - c) = 0, by simp,
have H3 : a = 0 ∨ b - c = 0, from mul_eq_zero H2,
or.imp_or_right H3 (assume H4 : b - c = 0, sub_eq_zero H4)
\end{minted}
\end{document}
</code></pre>
<p>You can compile <code>test.tex</code> by executing the following command:</p>
<pre><code class="language-bash">xelatex --shell-escape test
</code></pre>
<p>Some remarks:</p>
<ul>
<li>either <code>xelatex</code> or <code>lualatex</code> is required to handle Unicode characters in the code.</li>
<li><code>--shell-escape</code> is needed to allow <code>xelatex</code> to execute <code>pygmentize</code> in a shell.</li>
<li>If the chosen monospace font is missing some Unicode symbols, you can direct them to be displayed using a fallback font or other replacement LaTeX code.</li>
</ul>
<pre><code class="language-latex">\usepackage{newunicodechar}
\newfontfamily{\freeserif}{DejaVu Sans}
\newunicodechar{✝}{\freeserif{✝}}
\newunicodechar{𝓞}{\ensuremath{\mathcal{O}}}
</code></pre>
<ul>
<li>minted has a &quot;helpful&quot; feature that draws red boxes around characters the chosen lexer doesn't recognize.
Since the Lean lexer cannot encompass all user-defined syntax, it is advisable to <a href="https://tex.stackexchange.com/a/343506/14563">work around</a> this feature.</li>
</ul>
<h1><a class="header" href="#git-commit-convention" id="git-commit-convention">Git Commit Convention</a></h1>
<p>We are using the following convention for writing git-commit messages.
It is based on the one from AngularJS project(<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#">doc</a>,
<a href="https://github.com/angular/angular.js/commits/master">commits</a>).</p>
<h2><a class="header" href="#format-of-the-commit-message" id="format-of-the-commit-message">Format of the commit message</a></h2>
<pre><code>&lt;type&gt;: &lt;subject&gt;
&lt;NEWLINE&gt;
&lt;body&gt;
&lt;NEWLINE&gt;
&lt;footer&gt;
</code></pre>
<p><code>&lt;type&gt;</code> is:</p>
<ul>
<li>feat (feature)</li>
<li>fix (bug fix)</li>
<li>doc (documentation)</li>
<li>style (formatting, missing semicolons, ...)</li>
<li>refactor</li>
<li>test (when adding missing tests)</li>
<li>chore (maintain, ex: travis-ci)</li>
<li>perf (performance improvement, optimization, ...)</li>
</ul>
<p><code>&lt;subject&gt;</code> has the following constraints:</p>
<ul>
<li>use imperative, present tense: &quot;change&quot; not &quot;changed&quot; nor &quot;changes&quot;</li>
<li>do not capitalize the first letter</li>
<li>no dot(.) at the end</li>
</ul>
<p><code>&lt;body&gt;</code> has the following constraints:</p>
<ul>
<li>just as in <code>&lt;subject&gt;</code>, use imperative, present tense</li>
<li>includes motivation for the change and contrasts with previous
behavior</li>
</ul>
<p><code>&lt;footer&gt;</code> is optional and may contain two items:</p>
<ul>
<li>
<p>Breaking changes: All breaking changes have to be mentioned in
footer with the description of the change, justification and
migration notes</p>
</li>
<li>
<p>Referencing issues: Closed bugs should be listed on a separate line
in the footer prefixed with &quot;Closes&quot; keyword like this:</p>
<p>Closes #123, #456</p>
</li>
</ul>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<p>fix: add declarations for operator&lt;&lt;(std::ostream&amp;, expr const&amp;) and operator&lt;&lt;(std::ostream&amp;, context const&amp;) in the kernel</p>
<p>The actual implementation of these two operators is outside of the
kernel. They are implemented in the file 'library/printer.cpp'. We
declare them in the kernel to prevent the following problem. Suppose
there is a file 'foo.cpp' that does not include 'library/printer.h',
but contains</p>
<pre><code>expr a;
...
std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;
...
</code></pre>
<p>The compiler does not generate an error message. It silently uses the
operator bool() to coerce the expression into a Boolean. This produces
counter-intuitive behavior, and may confuse developers.</p>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<ul>
<li>C++14 compatible compiler</li>
<li><a href="http://www.cmake.org">CMake</a></li>
<li><a href="http://gmplib.org/">GMP (GNU multiprecision library)</a></li>
</ul>
<h2><a class="header" href="#platform-specific-setup" id="platform-specific-setup">Platform-Specific Setup</a></h2>
<ul>
<li><a href="make/ubuntu.html">Linux (Ubuntu)</a></li>
<li><a href="make/msys2.html">Windows (msys2)</a></li>
<li><a href="make/msvc.html">Windows (Visual Studio)</a></li>
<li><a href="make/osx-10.9.html">macOS (homebrew)</a></li>
<li>Linux/macOS/WSL via <a href="https://nixos.org/nix/">Nix</a>: Call <code>nix-shell</code> in the project root. That's it.</li>
<li>There is also an <a href="make/nix.html"><strong>experimental</strong> setup based purely on Nix</a> that works fundamentally differently from the
make/CMake setup described on this page.</li>
</ul>
<h2><a class="header" href="#generic-build-instructions" id="generic-build-instructions">Generic Build Instructions</a></h2>
<p>Setting up a basic release build:</p>
<pre><code class="language-bash">git clone https://github.com/leanprover/lean4
cd lean4
mkdir -p build/release
cd build/release
cmake ../..
make
</code></pre>
<p>Setting up a basic debug build:</p>
<pre><code class="language-bash">git clone https://github.com/leanprover/lean4
cd lean4
mkdir -p build/debug
cd build/debug
cmake -D CMAKE_BUILD_TYPE=DEBUG ../..
make
</code></pre>
<p>This will compile the Lean library and binary into the <code>stage1</code> subfolder; see
below for details. Add <code>-jN</code> for an appropriate <code>N</code> to <code>make</code> for a parallel
build.</p>
<h2><a class="header" href="#useful-cmake-configuration-settings" id="useful-cmake-configuration-settings">Useful CMake Configuration Settings</a></h2>
<p>Pass these along with the <code>cmake ../..</code> command.</p>
<ul>
<li>
<p><code>-D CMAKE_BUILD_TYPE=</code><br />
Select the build type. Valid values are <code>RELEASE</code> (default), <code>DEBUG</code>,
<code>RELWITHDEBINFO</code>, and <code>MINSIZEREL</code>.</p>
</li>
<li>
<p><code>-D CMAKE_C_COMPILER=</code><br />
<code>-D CMAKE_CXX_COMPILER=</code><br />
Select the C/C++ compilers to use. Official Lean releases currently use Clang;
see also <code>.github/workflows/ci.yml</code> for the CI config.</p>
</li>
</ul>
<p>Lean will automatically use <a href="https://ccache.dev/">CCache</a> if available to avoid
redundant builds, especially after stage 0 has been updated (see below).</p>
<h2><a class="header" href="#lean-build-pipeline" id="lean-build-pipeline">Lean Build Pipeline</a></h2>
<p>Since version 4, Lean is a partially bootstrapped program: most parts of the
frontend and compiler are written in Lean itself and thus need to be built before
building Lean itself - which is needed to again build those parts. This cycle is
broken by using pre-built C files checked into the repository (which ultimately
go back to a point where the Lean compiler was not written in Lean) in place of
these Lean inputs and then compiling everything in multiple stages up to a fixed
point. The build directory is organized in these stages:</p>
<pre><code class="language-bash">stage0/
  # Bootstrap binary built from stage0/src/.
  # We do not use any other files from this directory in further stages.
  bin/lean
stage1/
  include/
    config.h  # config variables used to build `lean` such as use allocator
    runtime/lean.h  # runtime headers, used by extracted C code, uses `config.h`
  share/lean/
    Makefile  # used by `leanmake`
  lib/
    lean/**/*.olean  # the Lean library (incl. the compiler) compiled by the previous stage's `lean`
    temp/**/*.{c,o}  # the library extracted to C and compiled by `leanc`
    libInit.a libStd.a libLean.a  # static libraries of the Lean library
    libleancpp.a  # a static library of the C++ sources of Lean
  bin/
    lean  # the Lean compiler &amp; server linked together from the above libraries
    leanc  # a wrapper around a C compiler supplying search paths etc
    leanmake  # a wrapper around `make` supplying the Makefile above
stage2/...
stage3/...
</code></pre>
<p>Stage 0 can be viewed as a blackbox since it does not depend on any local
changes and is equivalent to downloading a bootstrapping binary as done in other
compilers. The build for any other stage starts by building the runtime and
standard library from <code>src/</code>, using the <code>lean</code> binary from the previous stage in
the latter case, which are then assembled into a new <code>bin/lean</code> binary.</p>
<p>Each stage can be built by calling <code>make stageN</code> in the root build folder.
Running just <code>make</code> will default to stage 1, which is usually sufficient for
testing changes on the test suite or other files outside of the stdlib. However,
it might happen that the stage 1 compiler is not able to load its own stdlib,
e.g. when changing the .olean format: the stage 1 stdlib will use the format
generated by the stage 0 compiler, but the stage 1 compiler will expect the new
format. In this case, we should continue with building and testing stage 2
instead, which will both build and expect the new format. Note that this is only
possible because when building a stage's stdlib, we use the previous compiler
but never load the previous stdlib (since everything is <code>prelude</code>). We can also
use stage 2 to test changes in the compiler or other &quot;meta&quot; parts, i.e. changes
that affect the produced (.olean or .c) code, on the stdlib and compiler itself.
We are not aware of any &quot;meta-meta&quot; parts that influence more than two stages of
compilation, so stage 3 should always be identical to stage 2 and only exists as
a sanity check.</p>
<p>In summary, doing a standard build via <code>make</code> involves these steps:</p>
<ol>
<li>compile the <code>stage0/src</code> archived sources into <code>stage0/bin/lean</code></li>
<li>use it to compile the current library (<em>including</em> your changes) into <code>stage1/lib</code></li>
<li>link that and the current C++ code from <code>src/</code> into <code>stage1/bin/lean</code></li>
</ol>
<p>You now have a Lean binary and library that include your changes, though their
own compilation was not influenced by them, that you can use to test your
changes on test programs whose compilation <em>will</em> be influenced by the changes.</p>
<p>Finally, when we want to use new language features in the library, we need to
update the stage 0 compiler, which can be done via <code>make -C stageN update-stage0</code>.
<code>make update-stage0</code> without <code>-C</code> defaults to stage1.</p>
<h2><a class="header" href="#development-setup" id="development-setup">Development Setup</a></h2>
<p>After building a stage, you can invoke <code>make -C stageN test</code> (or, even better,
<code>make -C stageN test ARGS=-jN</code> to make <code>ctest</code> parallel) to run the Lean test suite.
<code>make test</code> without <code>-C</code> defaults to stage1. While the Lean tests will
automatically use that stage's corresponding Lean executables, for running tests
or compiling Lean programs manually, you need to put them into your <code>PATH</code>
yourself. A simple option for doing that is to use
<a href="https://github.com/leanprover/elan"><code>elan</code></a>, see the next section.</p>
<p>You can use any of the <a href="make/../setup.html">supported editors</a> for editing the Lean source
code. If you set up <code>elan</code> as below, opening <code>src/</code> as a <em>workspace folder</em> should
ensure that stage 0 will be used for file in that directory. You should also set the
<code>LEAN_SRC_PATH</code> environment variable to the path of the <code>src/</code> directory to enable
go-to-definition in the stdlib (automatically set when using <code>nix-shell</code>).</p>
<h2><a class="header" href="#dev-setup-using-elan" id="dev-setup-using-elan">Dev setup using elan</a></h2>
<p>You can use <a href="https://github.com/leanprover/elan"><code>elan</code></a> to easily switch between
stages and build configurations based on the current directory, both for the
<code>lean/leanc/leanmake</code> binaries in your shell's PATH and inside your editor.</p>
<p>If you haven't already installed elan, you can do so, without installing a
default version of Lean, using</p>
<pre><code class="language-bash">curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh -s -- --default-toolchain none
</code></pre>
<p>You can use <code>elan toolchain link</code> to give a specific stage build directory a
reference name, then use <code>elan override set</code> to associate such a name to the
current directory. We usually want to use <code>stage0</code> for editing files in <code>src</code>
and <code>stage1</code> for everything else (e.g. tests).</p>
<pre><code># in the Lean rootdir
elan toolchain link lean4 build/release/stage1
elan toolchain link lean4-stage0 build/release/stage0
# make `lean` etc. point to stage1 in the rootdir and subdirs
elan override set lean4
cd src
# make `lean` etc. point to stage0 anywhere inside `src`
elan override set lean4-stage0
</code></pre>
<p>You can also use the <code>+toolchain</code> shorthand (e.g. <code>lean +lean4-debug</code>) to switch
toolchains on the spot. <code>lean4-mode</code> will automatically use the <code>lean</code> executable
associated with the directory of the current file as long as <code>lean4-rootdir</code> is
unset and <code>~/.elan/bin</code> is in your <code>exec-path</code>. Where Emacs sources the
<code>exec-path</code> from can be a bit unclear depending on your configuration, so
alternatively you can also set <code>lean4-rootdir</code> to <code>&quot;~/.elan&quot;</code> explicitly.</p>
<p>You might find that debugging through elan, e.g. via <code>gdb lean</code>, disables some
things like symbol autocompletion because at first only the elan proxy binary
is loaded. You can instead pass the explicit path to <code>bin/lean</code> in your build
folder to gdb, or use <code>gdb $(elan which lean)</code>.</p>
<h2><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h2>
<ul>
<li>Call <code>make</code> with an additional <code>VERBOSE=1</code> argument to print executed commands.</li>
</ul>
<h2><a class="header" href="#installing-lean-on-ubuntu-1604" id="installing-lean-on-ubuntu-1604">Installing Lean on Ubuntu 16.04</a></h2>
<h3><a class="header" href="#basic-packages" id="basic-packages">Basic packages</a></h3>
<pre><code>sudo apt-get install git libgmp-dev cmake ccache
</code></pre>
<h2><a class="header" href="#install-packages-on-os-x-109" id="install-packages-on-os-x-109">Install Packages on OS X 10.9</a></h2>
<p>We assume that you are using <a href="http://brew.sh">homebrew</a> as a package manager.</p>
<h2><a class="header" href="#compilers" id="compilers">Compilers</a></h2>
<p>You need a C++11-compatible compiler to build Lean. As of November
2014, you have three options:</p>
<ul>
<li>clang++-3.5 (shipped with OSX, Apple LLVM version 6.0)</li>
<li>gcc-4.9.1 (homebrew)</li>
<li>clang++-3.5 (homebrew)</li>
</ul>
<p>We recommend to use Apple's clang++ because it is pre-shipped with OS
X and requires no further installation.</p>
<p>To install gcc-4.9.1 via homebrew, please execute:</p>
<pre><code>brew install gcc
</code></pre>
<p>To install clang++-3.5 via homebrew, please execute:</p>
<pre><code>brew install llvm --with-clang --with-asan
</code></pre>
<p>To use compilers other than the default one (Apple's clang++), you
need to use <code>-DCMAKE_CXX_COMPILER</code> option to specify the compiler
that you want to use when you run <code>cmake</code>. For example, do the
following to use <code>g++</code>.</p>
<pre><code>cmake -DCMAKE_CXX_COMPILER=g++ ...
</code></pre>
<h2><a class="header" href="#required-packages-cmake-gmp" id="required-packages-cmake-gmp">Required Packages: CMake, GMP</a></h2>
<pre><code>brew install cmake
brew install gmp
</code></pre>
<h2><a class="header" href="#recommended-packages-ccache" id="recommended-packages-ccache">Recommended Packages: CCache</a></h2>
<pre><code>brew install ccache
</code></pre>
<h2><a class="header" href="#lean-for-windows" id="lean-for-windows">Lean for Windows</a></h2>
<p>A native Lean binary for Windows can be generated using <a href="http://msys2.github.io">MSYS2</a>.
It is easy to install all dependencies, it produces native
64/32-binaries, and supports a C++14 compiler.</p>
<h2><a class="header" href="#installing-dependencies" id="installing-dependencies">Installing dependencies</a></h2>
<p><a href="http://msys2.github.io">The official webpage of MSYS2</a> provides one-click installers.
Once installed, you should run the &quot;MSYS2 MinGW 64-bit shell&quot; from the start menu.
Do not run &quot;MSYS2 MSYS&quot; instead!
MSYS2 has a package management system, <a href="https://wiki.archlinux.org/index.php/pacman">pacman</a>, which is used in Arch Linux.</p>
<p>Here are the commands to install all dependencies needed to compile Lean on your machine.</p>
<pre><code class="language-bash">pacman -S make mingw-w64-x86_64-cmake mingw-w64-x86_64-ccache mingw-w64-x86_64-clang git
</code></pre>
<p>Then follow the <a href="make/index.html">generic build instructions</a> in the MSYS2 MinGW shell, using
<code>cmake ../.. -G &quot;Unix Makefiles&quot;</code> instead of <code>cmake ../..</code>. This ensures that cmake will call <code>sh</code> instead
of <code>cmd.exe</code> for script tasks.</p>
<h2><a class="header" href="#install-lean" id="install-lean">Install lean</a></h2>
<p>You can use the <code>install</code> ninja/make target to install Lean into, by default,
<code>C:\\User Programs (x86)\\LEAN</code>. To change this, add <code>-DCMAKE_INSTALL_PREFIX=path/you/want</code>
to your cmake invocation.</p>
<p>While <a href="https://nixos.org/nix/">Nix</a> can be used to quickly open a shell with all dependencies for the <a href="make/index.html">standard setup</a> installed, the user-facing <a href="make/../setup.html#nix-setup">Nix Setup</a> can also be used to work <em>on</em> Lean.</p>
<h1><a class="header" href="#setup" id="setup">Setup</a></h1>
<p>Follow the setup in the link above; to open the Lean shell inside a Lean checkout, you can also use</p>
<pre><code class="language-bash"># in the Lean root directory
$ nix-shell -A nix
</code></pre>
<p>On top of the local and remote Nix cache, it helps to we do still rely on CCache as well to make C/C++ build steps incremental, which are atomic steps from Nix's point of view.
To enable CCache, add the following line to the config file mentioned in the setup:</p>
<pre><code class="language-bash">extra-sandbox-paths = /nix/var/cache/ccache
</code></pre>
<p>Then set up that directory as follows:</p>
<pre><code class="language-bash">sudo mkdir -m0770 -p /nix/var/cache/ccache
# macOS standard chown doesn't support --reference
nix shell .#nixpkgs.coreutils -c sudo chown --reference=/nix/store /nix/var/cache/ccache
</code></pre>
<h1><a class="header" href="#basic-build-commands" id="basic-build-commands">Basic Build Commands</a></h1>
<p>From the Lean root directory inside the Lean shell:</p>
<pre><code class="language-bash">nix build .#stage1  # build this stage's stdlib &amp; executable
nix build .#stage1.test  # run all tests
nix run .#stage1.update-stage0  # update ./stage0 from this stage
nix run .#stage1.update-stage0-commit  # ...and commit the results
</code></pre>
<p>The <code>stage1.</code> part in each command is optional:</p>
<pre><code class="language-bash">nix build .#test  # run tests for stage 1
nix build .  # build stage 1
nix build  # dito
</code></pre>
<h1><a class="header" href="#build-process-description" id="build-process-description">Build Process Description</a></h1>
<p>The Nix build process conceptually works the same as described in <a href="make/index.html#lean-build-pipeline">Lean Build Pipeline</a>.
However, there are two important differences in practice apart from the standard Nix properties (hermeneutic, reproducible builds stored in a global hash-indexed store etc.):</p>
<ul>
<li>Only files tracked by git (using <code>git add</code> or at least <code>git add --intent-to-add</code>) are compiled.
This is actually a general property of Nix flakes, and has the benefit of making it basically impossible to forget to commit a file (at least in <code>src/</code>).</li>
<li>Only files reachable from <code>src/Lean.lean</code> are compiled.
This is because modules are discovered not from a directory listing anymore but by recursively compiling all dependencies of that top module.</li>
</ul>
<h1><a class="header" href="#editor-integration" id="editor-integration">Editor Integration</a></h1>
<p>As in the standard Nix setup.
After adding <code>src/</code> as an LSP workspace, it should automatically fall back to using stage 0 in there.</p>
<p>Note that the UX of <code>emacs/vscode-dev</code> is quite different from the Make-based setup regarding the compilation of dependencies:
there is no mutable directory incrementally filled by the build that we could point the editor at for .olean files.
Instead, <code>emacs-dev</code> will gather the individual dependency outputs from the Nix store when checking a file -- and build them on the fly when necessary.
However, it will only ever load changes saved to disk, not ones opened in other buffers.</p>
<h1><a class="header" href="#other-fun-stuff-to-do-with-nix" id="other-fun-stuff-to-do-with-nix">Other Fun Stuff to Do with Nix</a></h1>
<p>Open Emacs with Lean set up from an arbitrary commit (without even cloning Lean beforehand... if your Nix is new enough):</p>
<pre><code class="language-bash">nix run github:leanprover/lean4/7e4edeb#emacs-package
</code></pre>
<p>Open a shell with <code>lean</code> and <code>LEAN_PATH</code> set up for compiling a specific module (this is exactly what <code>emacs-dev</code> is doing internally):</p>
<pre><code class="language-bash">nix develop .#mods.\&quot;Lean.Parser.Basic\&quot;
# alternatively, directly pass a command to execute:
nix develop .#stage2.mods.\&quot;Init.Control.Basic\&quot; -c bash -c 'lean $src -Dtrace.Elab.command=true'
</code></pre>
<p>Not sure what you just broke? Run Lean from (e.g.) the previous commit on a file:</p>
<pre><code class="language-bash">nix run .\?rev=$(git rev-parse @^) scratch.lean
</code></pre>
<p>Work on two adjacent stages at the same time without the need for repeatedly updating and reverting <code>stage0/</code>:</p>
<pre><code class="language-bash"># open an editor that will use only committed changes (so first commit them when changing files)
nix run .#HEAD-as-stage1.emacs-dev&amp;
# open a second editor that will use those commited changes as stage 0
# (so don't commit changes done here until you are done and ran a final `update-stage0-commit`)
nix run .#HEAD-as-stage0.emacs-dev&amp;
</code></pre>
<p>To run <code>nix build</code> on the second stage outside of the second editor, use</p>
<pre><code class="language-bash">nix build .#stage0-from-input
</code></pre>
<p>This setup will inadvertently change your <code>flake.lock</code> file, which you can revert when you are done.</p>
<p>...more surely to come...</p>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p>Since Nix copies all source files before compilation, you will need to map debug symbols back to the original path using <code>set substitute-path</code> in GDB.
For example, for a build on Linux with the Nix sandbox activated:</p>
<pre><code class="language-bash">(gdb) f
#1  0x0000000000d23a4f in lean_inc (o=0x1) at /build/source/build/include/lean/lean.h:562
562	/build/source/build/include/lean/lean.h: No such file or directory.
(gdb) set substitute-path /build/source/build src
(gdb) f
#1  0x0000000000d23a4f in lean_inc (o=0x1) at /build/source/build/include/lean/lean.h:562
562	static inline void lean_inc(lean_object * o) { if (!lean_is_scalar(o)) lean_inc_ref(o); }
</code></pre>
<p>This manual is generated by <a href="https://github.com/rust-lang/mdBook">mdBook</a>. We are currently using a
<a href="https://github.com/leanprover/mdBook">fork</a> of it for the following additional features:</p>
<ul>
<li>Add support for hiding lines in other languages <a href="https://github.com/rust-lang/mdBook/pull/1339">#1339</a></li>
<li>Replace calling <code>rustdoc --test</code> from <code>mdbook test</code> with <code>./test</code></li>
</ul>
<p>To build this manual, first install the fork via</p>
<pre><code class="language-bash">cargo install --git https://github.com/leanprover/mdBook mdbook
</code></pre>
<p>Then use e.g. <a href="https://rust-lang.github.io/mdBook/cli/watch.html"><code>mdbook watch</code></a> in the <code>doc/</code> folder:</p>
<pre><code class="language-bash">cd doc
mdbook watch --open  # opens the output in `out/` in your default browser
</code></pre>
<p>Run <code>mdbook test</code> to test all <code>lean</code> code blocks.</p>
<p>Using the <a href="make/nix.html">Nix setup</a>, you can instead open a shell with the mdBook fork downloaded from our binary cache:</p>
<pre><code class="language-bash">nix develop .#doc
</code></pre>
<h1><a class="header" href="#fixing-tests" id="fixing-tests">Fixing Tests</a></h1>
<p>The test suite contains some tests that compare the produced output
with the expected output. For example, the directory <code>tests/lean</code>
contains files such as <a href="../tests/lean/bad_class.lean"><code>bad_class.lean</code></a> and
<a href="../tests/lean/bad_class.lean.expected.out"><code>bad_class.lean.expected.out</code></a>.
The later contains the expected output for the test file <code>bad_class.lean</code>.</p>
<p>When the Lean source code or the standard library are modified, some of these
tests break because the produced output is slightly different, and we have
to reflect the changes in the <code>.lean.expected.out</code> files.
We should not blindly copy the new produced output since we may accidentally
miss a bug introduced by recent changes.
The test suite contains commands that allow us to see what changed in a convenient way.
First, we must install <a href="http://meldmerge.org/">meld</a>. On Ubuntu, we can do it by simply executing</p>
<pre><code>sudo apt-get install meld
</code></pre>
<p>Now, suppose <code>bad_class.lean</code> test is broken. We can see the problem by going to <code>test/lean</code> directory and
executing</p>
<pre><code>./test_single.sh -i bad_class.lean
</code></pre>
<p>When the <code>-i</code> option is provided, <code>meld</code> is automatically invoked
whenever there is discrepancy between the produced and expected
outputs. <code>meld</code> can also be used to repair the problems.</p>
<p>In Emacs, we can also execute <code>M-x lean4-diff-test-file</code> to check/diff the file of the current buffer.
To mass-copy all <code>.produced.out</code> files to the respective <code>.expected.out</code> file, use <code>tests/lean/copy-produced</code>.
When using the Nix setup, add <code>--keep-failed</code> to the <code>nix build</code> call and then call</p>
<pre><code class="language-sh">tests/lean/copy-produced &lt;build-dir&gt;/source/tests/lean
</code></pre>
<p>instead where <code>&lt;build-dir&gt;</code> is the path printed out by <code>nix build</code>.</p>
<h1><a class="header" href="#debugging-1" id="debugging-1">Debugging</a></h1>
<p>Some notes on how to debug Lean, which may also be applicable to debugging Lean programs in general.</p>
<h2><a class="header" href="#tracing" id="tracing">Tracing</a></h2>
<p>In <code>CoreM</code> and derived monads, we use <code>trace![traceCls] &quot;msg with {interpolations}&quot;</code> to fill the structured trace viewable with <code>set_option trace.traceCls true</code>.
New trace classes have to be registered using <code>registerTraceClass</code> first.</p>
<p>Notable trace classes:</p>
<ul>
<li>
<p><code>Elab.command</code>/<code>Elab.step</code>: command/term macro expansion/elaboration steps</p>
<p>Useful options modifying these traces for debugging syntax trees:</p>
<pre><code>set_option pp.raw true
set_option pp.raw.maxDepth 10
</code></pre>
</li>
<li>
<p><code>Meta.synthInstance</code>: typeclass resolution</p>
</li>
<li>
<p><code>Meta.isDefEq</code>: unification</p>
</li>
<li>
<p><code>interpreter</code>: full execution trace of the interpreter. Only available in debug builds.</p>
</li>
</ul>
<p>In pure contexts or when execution is aborted before the messages are finally printed, one can instead use the term <code>dbg_trace &quot;msg with {interpolations}&quot;; val</code> (<code>;</code> can also be replaced by a newline), which will print the message directly to stderr before evaluating <code>val</code>. <code>dbgTraceVal val</code> can be used as a shorthand for <code>dbg_trace &quot;{val}&quot;; val</code>.
Note that if the return value is not actually used, the trace code is silently dropped as well.</p>
<h2><a class="header" href="#debuggers" id="debuggers">Debuggers</a></h2>
<p><code>gdb</code>/<code>lldb</code> can be used to inspect stack traces of compiled Lean code, though they cannot print values of Lean variables and terms in any legible way yet.
For example, <code>b lean_panic_fn</code> can be used to look at the stack trace of a panic.</p>
<p>The <a href="https://github.com/rr-debugger/rr"><code>rr</code> reverse debugger</a> is an amazing tool for investigating e.g. segfaults from reference counting errors, though better hope you will never need it...</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
